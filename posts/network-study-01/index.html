<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.1" /><meta property="og:title" content="[네트워크 스터디] Chapter_01 웹 브라우저가 메세지를 만든다" /><meta property="og:locale" content="en" /><meta name="description" content="📗 Chapter_01 웹 브라우저가 메세지를 만든다 1. HTTP 리퀘스트 메세지를 작성한다" /><meta property="og:description" content="📗 Chapter_01 웹 브라우저가 메세지를 만든다 1. HTTP 리퀘스트 메세지를 작성한다" /><link rel="canonical" href="https://gzgzg2.github.io//posts/network-study-01/" /><meta property="og:url" content="https://gzgzg2.github.io//posts/network-study-01/" /><meta property="og:site_name" content="일하는 냐옹이" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-04-14T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[네트워크 스터디] Chapter_01 웹 브라우저가 메세지를 만든다" /><meta name="twitter:site" content="@none" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-04-14T00:00:00+09:00","datePublished":"2022-04-14T00:00:00+09:00","description":"📗 Chapter_01 웹 브라우저가 메세지를 만든다 1. HTTP 리퀘스트 메세지를 작성한다","headline":"[네트워크 스터디] Chapter_01 웹 브라우저가 메세지를 만든다","mainEntityOfPage":{"@type":"WebPage","@id":"https://gzgzg2.github.io//posts/network-study-01/"},"url":"https://gzgzg2.github.io//posts/network-study-01/"}</script><title>[네트워크 스터디] Chapter_01 웹 브라우저가 메세지를 만든다 | 일하는 냐옹이</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="일하는 냐옹이"><meta name="application-name" content="일하는 냐옹이"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/profile/navi_1.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">일하는 냐옹이</a></div><div class="site-subtitle font-italic">잠 자는게 좋아</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/gzgzg2" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/none" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['parkuram12','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[네트워크 스터디] Chapter_01 웹 브라우저가 메세지를 만든다</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>[네트워크 스터디] Chapter_01 웹 브라우저가 메세지를 만든다</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1649862000" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Apr 14, 2022 </em> </span> <span> Updated <em class="" data-ts="1649894400" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Apr 14, 2022 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://github.com/gzgzg2">박우람</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5162 words"> <em>28 min</em> read</span></div></div></div><div class="post-content"><h1 id="-chapter_01-웹-브라우저가-메세지를-만든다">📗 Chapter_01 웹 브라우저가 메세지를 만든다</h1><h2 id="1-http-리퀘스트-메세지를-작성한다"> <a href="#1-http-리퀘스트-메세지를-작성한다" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> <strong>1. HTTP 리퀘스트 메세지를 작성한다</strong></h2><h3 id="1️⃣-url"> <a href="#1️⃣-url" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> <strong>1️⃣  URL</strong></h3><p><strong>✔️ HTTP URL 의 구성</strong></p><p>ex ) <a href="http://user:passwork@www.cyber.co.kr">http://user:password@www.example.co.kr</a>:80/dir/file1.html</p><ul><li>프로토콜 → http<li>사용자명 (생략 가능) → user<li>패스워드 (생략 가능) → password<li>웹 서버의 도메인명 → <a href="http://www.example.co.kr">www.example.co.kr</a><li>포트번호 (생략 가능) → 80<li>파일의 경로명 → /dir/file1.html</ul><p><strong>💡 HTTP 의 경우 기본 포트는 80이고 HTTPS의 기본 포트는 443이다.</strong></p><p><br /></p><p>✔️ <strong>URL 은 여러 종류가 있다.</strong></p><p>URL은 http로 구성되어있는 것 말고도 ftp: 나 mailto: 같은 다양한 프로토콜의 URL이 존재한다. 이유는, 브라우저는 웹 서버에 엑세스하는 클라이언트로만 사용하는 것이 아니라 파일을 다운로드/업로드하는 FTP의 기능이나</p><p>메일클라이언트의 기능도 가지고 있기 때문이다. 브라우저는 URL을 토대로 여러개의 기능 중 어느것을 사용하여 데이터에 엑세스하면 될지를 판단한다.</p><p><br /></p><p><strong>✔️ 다양한 URL의 구성</strong></p><p><img data-src="https://user-images.githubusercontent.com/56028408/163106926-34b4cb16-6547-41bb-b016-0b2c4e6b081a.png" alt="image" data-proofer-ignore></p><p>이와같이 쓰는 방법은 다양하지만 모든 URL에는 하나의 공통점이 있다. URL 맨 앞에 있는 프로토콜에 따라서 액세스 하는 대상이 달라진다는 것이다.</p><p>예를 들어 액세스 대상이 웹 서버라면 HTTP 프로토콜을 사용하고, FTP 서버라면 FTP, 메일을 송신할 때는 mailto 프로토콜을 사용하면 된다.</p><p><br /></p><h3 id="2️⃣--브라우저의-url-해독-방식"> <a href="#2️⃣--브라우저의-url-해독-방식" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 2️⃣ <strong>브라우저의 URL 해독 방식</strong></h3><p>웹 서버에 보내는 리퀘스트 메세지를 작성하기 전에 URL을 해독한다. 아래 내용은 브라우저가 웹 서버에 엑세스하는 경우를 예로들어 설명한다.</p><p><strong>URL을 요소별로 분리하여 나열한 것은 아래와 같다.</strong></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="n">http</span><span class="o">:</span><span class="c1">//www.example.co.kr](http://user:passwork@www.cyber.co.kr):80/dir/file1.html</span>
<span class="p">[</span> <span class="n">http</span> <span class="p">]</span><span class="o">:</span> <span class="o">+</span> <span class="p">[</span> <span class="c1">// ] + [ 웹 서버명 ] + [ / ] + [ 디렉토리명 ] +[ / ] + .... + [ 파일명 ]   </span>
</pre></table></code></div></div><p>http는 앞서 설명한 프로토콜이 되는 것이고 //는 나중에 이어지는 문자열이 서버의 이름임을 나타낸다.</p><p>웹 서버명 다음에 이어지는 것은 서버에 파일이 저장된 위치인데 이는 생략이 가능하다.</p><hr /><p><strong>✔️  파일명을 생략한 경우</strong></p><p>ex) <a href="http://user:passwork@www.cyber.co.kr">http://www.example.co.kr</a></p><p>예시 url은 파일명을 생략했을 때의 url이다. 파일명을 생략하면 서버가 어느 파일에 액세스해야 하는 지 알 수 없다.</p><p>그래서 이와같은 문제를 대비하여 서버에서 파일명이 생략되었을 때 액세스할 default 파일을 설정해둔다. 대부분의 서버는 index.html 이나 default.html 이라는 파일명으로 설정해둔다.</p><p><strong>💡  브라우저가 가장 먼저 하는 일은 URL 해독이다.</strong></p><h3 id="3️⃣http의-기본-개념"> <a href="#3️⃣http의-기본-개념" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 3️⃣ HTTP의 기본 개념</h3><blockquote><p>Hyper-Text Transfer Protocol(HTTP)란 지정된 규약을 지켜 웹 서버와 데이터를 주고받는 서버/클라이언트 모델을 따르는 비연결성 &amp; 무상태 프로토콜이다.</p><p>애플리케이션 레벨의 프로토콜로 TCP/IP 위에서 작동한다. HTTP 패킷에는 여러 메타데이터와 성공 실패 정보가 담겨있으므로 서버와 클라이언트가 원활하게 대화할 수 있다.</p></blockquote><p><strong>💡  비연결성</strong></p><p>연결을 유지하지 않는 것 특정한 옵션을 주면 일정시간동안 연결을 유지할 수는 있다.</p><p><strong>💡  무상태</strong></p><p>서버가 클라이언트의 상태를 보존하지 않는 것 매번 요청에 모든 상태값들을 전달해줘야 함 상태를 유지해줘야 할 경우 쿠키나 세션을 사용 함</p><p><br /></p><p><strong>✔️ HTTP Reuqest 패킷 구성</strong></p><p><img data-src="https://user-images.githubusercontent.com/56028408/163209206-2d7e3008-230e-4da7-9041-453bcfa2d23d.png" alt="image" data-proofer-ignore></p><p>HTTP 요청 패킷은 크게 요청라인, 메세지 정보, 본문으로 나눌 수 있다.</p><ul><li>요청라인 → HTTP Method, URL, HTTP 버전<li>메세지 정보 → 해당 요청에 대한 메타데이터를 담고있는 공간<li>본문(body) → 해당 요청의 실제 내용. POST가 아니여도 body를 사용할 수 있지만, 주로 Body를 사용하는 메소드는 POST이다.</ul><p><br /></p><p><strong>✔️ HTTP Response 패킷 구성</strong></p><p><img data-src="https://user-images.githubusercontent.com/56028408/163209182-d49ace5d-d8c1-4e7b-aa31-976c9cdbafb5.png" alt="image" data-proofer-ignore></p><p>HTTP 응답 패킷은 크게 상태라인, 메세지 정보, 본문으로 나눌 수 있다.</p><ul><li>상태라인 → HTTP Method, 버전, 응답코드<ul><li>응답코드는 주로 권한과 서버에러, 클라이언트에러 등으로 나눠서 성공과 실패 여부를 판단하는데에 사용된다,</ul><li>메세지 정보 → 해당 응답에 대한 메타데이터를 담고있는 공간<li>본문(body) → 요청의 Body와 일반적으로 동일하다. body 존재할 수도 있고 존재하지 않을수도 있다. 가장 많이 사용되는 Body의 데이터 타입은 JSON(JavaScript Object Notation)이다.</ul><p><br /></p><p><strong>✔️ HTTP Method</strong></p><p>HTTP 메소드를 정리한 표이다. 버전마다 지원되는 메소드가 다르다.</p><div class="table-wrapper"><table><thead><tr><th>메소드<th>의미<tbody><tr><td>GET<td>지정한 정보를 도출할 때 사용된다. 파일의 경우 해당 파일의 내용을 되돌려보낸다.<tr><td>POST<td>클라이언트에서 데이터를 body에 담아 송신할 때 사용된다.<tr><td>PUT<td>URI로 지정한 서버의 파일을 치환한다. 파일이 없는 경우 새로 등록한다.<tr><td>DELETE<td>URL로 지정한 서버의 파일을 삭제한다.<tr><td>PATCH<td>리소스의 일부분만을 수정하는데에 쓰인다.<tr><td>OPTION<td>통신 옵션을 통지하거나 조사할 때 사용된다.<tr><td>HEAD<td>GET과 거의 같지만 데이터의 내용을 돌려보내지 않고 HTTP 메세지 헤더만을 반송한다. 속성 정보를 조사할 때 사용된다.<tr><td>TRACE<td>서버측에서 받은 리퀘스트 라인과 헤더를 그대로 클라이언트에 반송한다. 프록시 서버 등을 사용하는 환경에서 리퀘스트가 치환되는 상태를 조사할 떄 사용된다.<tr><td>CONNECT<td>암호화한 메세지를 프록시로 전송할 때 이용된다.</table></div><p><br /></p><p><strong>✔️ HTTP 간단한 통신과정 예시</strong></p><p><img data-src="https://user-images.githubusercontent.com/56028408/163209168-f37b8432-03fc-4dbf-883e-001f24d63871.png" alt="image" data-proofer-ignore></p><ol><li>웹서버에 특정 리소스를 얻기 위해 URI와 헤더에 요청에 필요한 정보를 담아 서버에 전송한다.<li>해당 리소스가 존재하면 응답 헤더에 필요한 정보를 담아서 보내거나 바디에 해당 요청 데이터를 전송한다.</ol><p>🌟 <strong>실제로 요청과 응답 사이에 검증절차나 여러가지 일들이 일어나지만 자세한 내용은 생략하겠다.</strong></p><h2 id="2-웹-서버의-ip-주소를-dns-서버에-조회한다"> <a href="#2-웹-서버의-ip-주소를-dns-서버에-조회한다" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 2. 웹 서버의 IP 주소를 DNS 서버에 조회한다</h2><blockquote><p>HTTP 메세지를 만드는 것에 성공하면 이것을 OS에 의뢰하여 액세스 대상의 웹 서버에게 송신한다.</p><p>브라우저는 URL을 해독하거나 HTTP 메세지를 만들 수는 있지만 메세지를 네트워크에 송출하는 기능은 없으므로 OS에 의뢰하는 것이다.</p><p>이때 URL 안에 쓰여있는 서버의 도메인 명에서 IP 주소를 조사해야하는데, 이는 OS에서 송신을 의뢰할때는 도메인명이 아니라 IP 주소로 메세지를 받을 상대를 지정해야하기 때문이다.</p></blockquote><p><strong>✔️  도메인명과 IP 주소를  구분하여 사용하는 이유</strong></p><p>TCP/IP 네트워크는 IP 주소로 통신 상대를 지정하므로 IP주소를 모르는 상대에게 메세지를 전달할 수 없다. 이러한 이유 때문에 도메인 명과 IP 주소를 구분하는 것이다. 웹 브라우저는 Socket 라이브러리를 사용하여 도메인 명으로 IP 주소를 조회한다. 그렇다면 URL 안에서는 서버명이 아니라 IP 주소를 사용하는 것이 더 효율적이라는 생각이 들 수 있다. 실제로 서버명 대신에 IP 주소를 사용해도 올바르게 작동한다.그렇지만 기억하기 어렵다는 단점이 있다. 실행 효율 관점에서 바라보면 IP 주소대신 도메인명으로 사용하는 것이 좋은 방법이라고 할 수 없다. IP 주소는 32비트로 4바이트에 해당하는 개수밖에 없지만, 도메인 명은 수십 바이트 부터 최대 255 바이트 까지 존재한다. 그러면 그만큼 라우터가 부하되어 데이터를 운반하는 동작에 더 많은 시간이 걸릴 것이다. 하지만 이름을 알면 IP 주소를 알 수 있다거나 IP 주소를 사용하면 이름을 알 수있다는 원리를 이용하여 양쪽의 차이를 해소한 DNS가 라우터 부하의 문제점을 해결해준다.</p><p><br /></p><p><strong>✔️ Socket 라이브러리의 IP 주소 조회</strong></p><p>웹 브라우저는 Socket 라이브러리의 도움을 받아 DNS서버에서 도메인명의 IP 주소를 조회할 수 있다.</p><p>DNS 서버에서 조회한다는 것은 DNS 서버에 메세지를 보내고 반송되는 응답 메세지를 받는 것이다. 이것은 DNS 클라이언트로 동작한다고 말할 수 있다. DNS 클라이언트에 해당되는 것을 DNS 리졸버(=리졸버)라고 한다.</p><p>DNS 원리를 이용하여 IP 주소를 조사하는 것을 네임 리졸루션 (name resolution) 이라고 하는데 리졸루션을 수행하는 것이 리졸버이다.</p><p><br /></p><p><strong>💡 Socket 라이브러리</strong></p><ul><li>OS를 이용하여 네트워크의 기능을 호출하기 위한 프로그램의 부품집</ul><p><br /></p><h3 id="️리졸버-내부의-작동"> <a href="#️리졸버-내부의-작동" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> ✔️ 리졸버 내부의 작동</h3><p><img data-src="https://user-images.githubusercontent.com/56028408/163209513-02792b34-4c07-4427-9ed5-0f0a68b403ce.png" alt="image" data-proofer-ignore></p><p>✔️  <strong>리졸버를 이용하여 DNS 서버를 조회한다.</strong></p><p>리졸버의 프로그램명(gethostbyname)과 웹 서버의 이름을 쓰기만 하면 리졸버를 호출할 수 있다. </p><ol><li>브라우저 애플리케이션이 Socket 라이브러리의 리졸버를 호출한다. 이때 gethostbyname에 웹서버 이름을 전달한다.<li>리졸버가 DNS 서버에 조회 메세지를 보낸다. 메세지 송신 동작은 OS 내부의 프로토콜 스택을 호출하여 수행한다.<li>DNS 서버에서 돌아온 응답 메세지를 수신한다.<li>응답 메세지에서 IP 주소를 추출하고 메모리 영역에 저장한 뒤 애플리케이션으로 돌아간다.</ol><p><br /></p><p>🌟  DNS 서버에 메세지를 송신할 때도 DNS 서버의 IP 주소가 필요한데, 이는 컴퓨터의 TCP/IP 설정 항목의 하나로 컴퓨터에 미리 설정되어 있다. </p><h2 id="3-전-세계의-dns-서버가-연대한다"> <a href="#3-전-세계의-dns-서버가-연대한다" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 3. 전 세계의 DNS 서버가 연대한다</h2><h3 id="1️⃣-dns-서버의-기본동작"> <a href="#1️⃣-dns-서버의-기본동작" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 1️⃣ <strong>DNS 서버의 기본동작</strong></h3><p>DNS 서버의 기본 동작은 클라이언트에서 조회 메세지를 받고 조회의 내용에 응답하는 형태로 정보를 회답하는 일이다.</p><p><br /></p><p><strong>✔️  조회 메세지 구성</strong></p><ul><li>이름<ul><li>서버의 메일 배송 목적지와 같은 이름, 도메인 명</ul><li>클래스<ul><li>네트워크 종류를 검토하기위해 사용되는 것 현재는 인터넷 외의 네트워크는 소멸되었기 때문에 항상 인터넷을 나타내는 IN 값이 전달된다</ul><li>타입<ul><li>이름에 어떤 타입의 정보가 지원되는지를 나타낸다. 타입이 A이면 이름에 IP 주소가 지원되는 것을 나타내고 MX이면 이름에 메일 배송 목적지가 지원된다는 것을 나타낸다. 타입에 따라 클라리언트에 회답하는 정보의 내용이 달라진다.</ul></ul><p>이름이 <a href="http://www.example.com">www.example.com</a> 인 서버의 IP 주소를 조사할 때 클라이언트는 다음과 같은 메세지를 보낸다.</p><p>해당 메세지를 수신했을 때 DNS가 어떠한 동작을 하는지 알아보자</p><p><br /></p><p><strong>[요청 메세지 예시 ]</strong></p><ul><li>이름 = www.example.com<li>클래스 = IN<li>타입 = A</ul><p><br /></p><p><strong>[DNS 서버 내부 등록 정보 예시]</strong></p><div class="table-wrapper"><table><thead><tr><th>이름<th>클래스<th>타입<th>클라이언트에 회답하는 항목<tbody><tr><td>www.example.com<td>IN<td>A<td>192.168.2.5<tr><td>example.com<td>IN<td>MX<td>192.168.2.6</table></div><p><br /></p><p><strong>[DNS 서버의 동작]</strong></p><ol><li>DNS가 메세지를 수신하면 DNS 서버는 이름, 클래스, 타입의 값이 일치하는 데이터를 찾는다.<li>일치하는 데이터가 있으면 요청 값에 맞는 데이터를 클라이언트에게 전송한다. (예제를 기준으로 하면 192.168.2.5)</ol><p> <strong>💡  DNS 서버는 서버에 등록된 도메인명과 IP 주소의 대응표를 조사하여 IP 주소를 회답한다.</strong></p><p><br /></p><h3 id="2️⃣-도메인의-계층"> <a href="#2️⃣-도메인의-계층" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 2️⃣  도메인의 계층</h3><blockquote><p>인터넷에선 막대한 수의 서버가 존재하기 때문에 모든 도메인 명을 하나의 DNS 서버에 등록하는 것은 불가능하다.</p><p>이러한 문제점은 정보를 분산시켜 다수의 DNS 서버에 등록하는 방식으로 해결할 수 있다. 다수의 DNS 서버는 계층적으로 구성되어있는데, 이는 조회 메세지를 수신한 DNS 서버에 해당 정보가 등록되어 있지 않아도 계층적으로 연대하고 있는 다른 DNS 서버에서 찾을 수 있다.</p></blockquote><p>DNS 서버에 등록된 모든 정보는 모든 도메인명이라는 계층적 구조를 가진 이름이 붙여져 있다. DNS에서 취급하는 이름은 <a href="http://www.example.com">www.example.com</a> 처럼 점으로 구분되어 있는데, 점으로 게층을 구분한다. 오른쪽에 위치한 것이 상위 계층이다. 계층구조와 같은 형태로 DNS 서버가 배치되며, 각 계층은 각자의 DNS 서버에 저장된다.</p><p><br /></p><p><strong>[계층 구조 예시]</strong></p><p>URL → <a href="http://www.example.com">www.example.com</a></p><p>오른쪽에 위치한 것이 상위 계층이다.</p><ul><li>com<ul><li>example<ul><li>www</ul></ul></ul><p><br /></p><p><strong>✔️  담당 DNS 서버를 찾아 IP 주소를 가져온다</strong></p><blockquote><p>인터넷에는 DNS 서버가 수만 대가 있으므로 닥치는 대로 이를 뒤지면서 해당 도메인의 IP를 찾을 수는 없다.</p><p>그래서 다음과 같은 방법으로 이를 해결한다.</p></blockquote><h4 id="예시"> <a href="#예시" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> <strong>[예시]</strong></h4><p>URL → <a href="http://www.example.com">www.example.com</a></p><p>예시 URL 기준으로 최상위 도메인은 com이다. 하지만 실제로 URL은 com이나 kr 위에 루트 도메인이 존재한다. 루트 도메인은 com이나 kr같은 도메인 명이 존재하지 않기 때문에 보통 도메인을 쓸 때는 이것을 생략한다. 명시적으로 <a href="http://www.example.com">www.example.com</a>. 처럼 URL 끝에 마침표를 찍기도 하지만 보통은 그렇게 사용하지 않는다.</p><ol><li>하위의 도메인을 담당하는 DNS 서버의 IP 주소를 상위의 DNS 서버에 등록한다. <li>상위의 DNS 서버를 또 그 상위의 DNS 서버에 등록한다.<li>상위의 DNS 서버가 존재하면 이를 반복한다.</ol><p>💡 <strong>이러한 방식은 상위 DNS 서버에서 하위의 DNS 서버의 IP 주소를 알 수 있다. (루트 도메인을 모든 DNS 서버에 등록하면 루트 도메인의 모든 하위 DNS 서버를 조회할 수 있음)</strong></p><p><br /></p><h4 id="ip-조회"> <a href="#ip-조회" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> <strong>[IP 조회]</strong></h4><p><img data-src="https://user-images.githubusercontent.com/56028408/163209731-4d525bc3-91f4-4d27-8a0e-e297b3456a1a.png" alt="image" data-proofer-ignore></p><ol><li>가장 가까운 DNS 서버에게 해당 도메인 명의 IP를 요청한다.<li>IP가 등록되어있지 않을 경우 루트 도메인 서버에게 해당 IP를 요청한다.<li>루트 도메인에도 해당 IP가 등록되지 않았을 경우 하향식으로 접근하여 IP를 찾을 때까지 하위 도메인 서버에 해당 IP 정보를 요청한다.</ol><p><br /></p><p>💡  <strong>앞서 설명한 내용은 기본이 되는 동작을 설명한 것으로 현실의 인터넷과 모든 동작이 일치하진 않는다. 현실의 인터넷은 한 대의 DNS 서버에 복수의 DNS 서버를 등록할 수 있으므로 한 도메인에 한대씩 DNS 서버가 존재한다고 단정할 수 없다.</strong></p><h3 id="3️⃣dns-서버는-캐시-기능으로-빠르게-회답할-수-있다"> <a href="#3️⃣dns-서버는-캐시-기능으로-빠르게-회답할-수-있다" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 3️⃣  DNS 서버는 캐시 기능으로 빠르게 회답할 수 있다.</h3><p>DNS 서버는 한번 조사한 도메인 명을 캐싱할 수 있다. 요청받은 도메인 명이 캐싱되어 있으면 캐싱되어 있는 정보를 전달한다. 정보가 없을 경우에도 캐싱하기 때문에 정보가 존재하지 않는 다는 것도 빠르게 회답할 수 있다. 하지만 캐시된 정보가 변경될 수도 있으므로 캐시안에 저장된 정보를 올바르다고 단언할 수는 없다.</p><h2 id="4-프로토콜-스택에-메시지-송신을-의뢰한다"> <a href="#4-프로토콜-스택에-메시지-송신을-의뢰한다" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 4. <strong>프로토콜 스택에 메시지 송신을 의뢰한다</strong></h2><p>IP 주소를 조사를 마치면 액세스 대상 웹 서버에 메세지를 송신하도록 OS 내부 프로토콜 스택에 의뢰한다.</p><p>이 동작에서도 Socket 라이브러리를 사용하는데, 복수의 부품을 결정된 순서대로 호출해야하므로 복잡하다.</p><p><br /></p><p>🌟 <strong>Socket 라이브러리를 이용한 데이터 송 수신 동작</strong></p><p><img data-src="https://user-images.githubusercontent.com/56028408/163209131-ddef6b53-6743-413a-abae-c4b862dcfde6.png" alt="image" data-proofer-ignore></p><ol><li>서버측에서 소켓을 생성하고 클라이언트가 파이프를 연결하기를 기다린다. (소켓 생성 단계)<li>클라이언트가 서버측 소켓에 파이프를 연결한다 (소켓 접속 단계)<li>연결이 성공하면 데이터를 송 수신 한다 (송 수신 단계)<li>송 수신 동작이 끝나면 파이프 연결을 해제한다. (연결은 클라이언트, 서버 둘 중 어느 쪽에서 분리해도 상관없다.)</ol><p><br /></p><p><strong>🌟  결정된 순서대로 Socket 라이브러리를 호출하는 애플리케이션 예시</strong></p><p><img data-src="https://user-images.githubusercontent.com/56028408/163209107-a08c09a6-c0f1-4509-b64c-adae70159364.png" alt="image" data-proofer-ignore></p><ul><li>socket()<ul><li>소켓을 생성하고 완료되면 제어권을 애플리케이션에게 넘긴다. 소켓이 생성되면 <strong>디스크립터</strong>가 반환되는데, 이는 소켓을 식별하기 위한 식별자의 용도로 사용된다.</ul><li>connect()<ul><li>디스크립터, 서버의 IP 주소, 포트번호 세 가지 값을 입력하여 특정 소켓에 연결을 요청한다.</ul><li>wirte()<ul><li>송신 데이터를 메모리에 할당하고 wirte() 함수를 호출할 때 디스크립터와 송신데이터를 지정한다. 소켓에는 연결된 상대가 기록되어 있으므로 디스크립터로 소켓을 지정하면 연결된 상대가 판명된다.</ul><li>read()<ul><li>메세지를 수신할 때 사용된다. 수신한 응답메세지는 수신 버퍼에 저장된다. 수신버퍼는 애플리케이션 내부에 마련된 메모리 영역이므로 수신 버퍼에 메세지를 저장한 시점에 애플리케이션에게 메세지를 넘겨준다.</ul><li>close()<ul><li>메세지 송 수신이 완료되면 연결을 종료하는 함수 만약 read 동작을 수행하고 있는 도중에 연결이 종료되면 수신한 데이터를 건네주고 연결을 종료한다.</ul></ul><p><br /></p><p><strong>🌟  디스크립터 = 애플리케이션이 소켓을 식별하는 용도</strong></p><p><strong>🌟  IP와 포트번호 = 클라이언트와 서버 간에 상대의 소켓을 식별하는 용도</strong></p><p><strong>🌟  요청에는 하나의 리소스 정보만을 표시하고 있기 때문에 여러 파일의 정보를 읽으려면 요청을 각각 보내야한다. 요청을 각각 보내면 매번 TCP Connection 을 새로 맺어야하는데, 이는 비효율적일 수 있다. 그래서 HTTP 1.1 버전부터 일정시간동안 연결을 유지할 수 있는 옵션이 추가되었다.</strong></p><p><br /> <br /></p><h1 id="reference">Reference</h1><p><a href="https://velog.io/@anhesu11/HTTP-%EA%B8%B0%EB%B3%B8-%EC%9D%B4%EB%A1%A0-%EC%A0%95%EB%A6%AC">https://velog.io/@anhesu11/HTTP-기본-이론-정리</a></p><p>성공과 실패를 결정하는 1%의 네트워크</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/networkstudy/'>networkStudy</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/http/" class="post-tag no-text-decoration" >HTTP</a> <a href="/tags/socket/" class="post-tag no-text-decoration" >Socket</a> <a href="/tags/dns/" class="post-tag no-text-decoration" >DNS</a> <a href="/tags/tcp/" class="post-tag no-text-decoration" >TCP</a> <a href="/tags/%EC%84%B1%EA%B3%B5%EA%B3%BC-%EC%8B%A4%ED%8C%A8%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-1-%EC%9D%98-%EC%9B%90%EB%A6%AC/" class="post-tag no-text-decoration" >성공과 실패를 위한 네트워크 1%의 원리</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%5B%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC+%EC%8A%A4%ED%84%B0%EB%94%94%5D+Chapter_01+%EC%9B%B9+%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EA%B0%80+%EB%A9%94%EC%84%B8%EC%A7%80%EB%A5%BC+%EB%A7%8C%EB%93%A0%EB%8B%A4+-+%EC%9D%BC%ED%95%98%EB%8A%94+%EB%83%90%EC%98%B9%EC%9D%B4&url=https%3A%2F%2Fgzgzg2.github.io%2F%2Fposts%2Fnetwork-study-01%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%5B%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC+%EC%8A%A4%ED%84%B0%EB%94%94%5D+Chapter_01+%EC%9B%B9+%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EA%B0%80+%EB%A9%94%EC%84%B8%EC%A7%80%EB%A5%BC+%EB%A7%8C%EB%93%A0%EB%8B%A4+-+%EC%9D%BC%ED%95%98%EB%8A%94+%EB%83%90%EC%98%B9%EC%9D%B4&u=https%3A%2F%2Fgzgzg2.github.io%2F%2Fposts%2Fnetwork-study-01%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fgzgzg2.github.io%2F%2Fposts%2Fnetwork-study-01%2F&text=%5B%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC+%EC%8A%A4%ED%84%B0%EB%94%94%5D+Chapter_01+%EC%9B%B9+%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EA%B0%80+%EB%A9%94%EC%84%B8%EC%A7%80%EB%A5%BC+%EB%A7%8C%EB%93%A0%EB%8B%A4+-+%EC%9D%BC%ED%95%98%EB%8A%94+%EB%83%90%EC%98%B9%EC%9D%B4" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div><script src="https://utteranc.es/client.js" repo="gzgzg2/blog-comments" issue-term="pathname" label="Comment🐱" theme="github-light" crossorigin="anonymous" async> </script></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/strategy-pattern/">[Java Design Pattern] Strategy Pattern</a><li><a href="/posts/http2/">HTTP/2</a><li><a href="/posts/toby-spring-chapter-2/">[토비의 스프링] 토비의 스프링 3.1 2장 테스트</a><li><a href="/posts/toby-spring-chapter-1/">[토비의 스프링] 토비의 스프링 3.1 1장 오브젝트와 의존관계</a><li><a href="/posts/spring-applicationcontext/">SpringFramework - Web ApplicationContext</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%EB%B0%98%ED%9A%A8%EA%B2%BD/">반효경</a> <a class="post-tag" href="/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80-%EC%A0%95%EB%B3%B4%EA%B8%B0%EC%88%A0%EC%9D%98-%EC%9B%90%EB%A6%AC/">운영체제와 정보기술의 원리</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/operating-system/">Operating System</a> <a class="post-tag" href="/tags/dns/">DNS</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/">운영체제</a> <a class="post-tag" href="/tags/%ED%86%A0%EB%B9%84%EC%9D%98-%EC%8A%A4%ED%94%84%EB%A7%81/">토비의 스프링</a> <a class="post-tag" href="/tags/gof/">Gof</a> <a class="post-tag" href="/tags/os/">OS</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/network-study-02/"><div class="card-body"> <em class="small" data-ts="1651158000" data-df="ll" > Apr 29, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[네트워크 스터디] Chapter_02 TCP/IP의 데이터를 전기 신호로 만들어 보낸다</h3><div class="text-muted small"><p> 📗 Chapter_02 TCP/IP의 데이터를 전기 신호로 만들어 보낸다 🌟 2장의 요점 짚고 넘어가기 🌟 Chapter 02에선 OS에 내장된 프로토콜 스택이 처음 등장한다. 프로토콜 스택은 네트워크 제어용 소프트웨어이다. 프로토콜 스택은 브라우저에서 받은 메세지를 패킷 속에 저장하고, 수신처 주소 등의 제어 정보를 덧붙인다. 프로토콜 스택은...</p></div></div></a></div><div class="card"> <a href="/posts/dns/"><div class="card-body"> <em class="small" data-ts="1651330800" data-df="ll" > May 1, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>DNS 란?</h3><div class="text-muted small"><p> 브라우저에 “www.naver.com” 입력하면? DNS가 무엇인지 알아보기 전에 먼저 브라우저에 “www.naver.com” 을 입력했을 때 어떻게 해당 도메인의 IP를 조회하는지 알아보자 브라우저 애플리케이션이 “도메인명”을 조회하는 DNS 리졸버 호출 DNS 리졸버가 DNS 서버에 보내는 조회 메시지를 생성 프로토콜 스택이 DN...</p></div></div></a></div><div class="card"> <a href="/posts/network-study-04/"><div class="card-body"> <em class="small" data-ts="1654614000" data-df="ll" > Jun 8, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[네트워크 스터디] Chapter_04 엑세스 회선을 통해 인터넷의 내부로 !</h3><div class="text-muted small"><p> ADSL 기술을 이용한 엑세스 회선의 구조와 동작 ✔️  인터넷의 기본은 가정이나 회사의 LAN과 같다 인터넷은 거대하고 복잡한 시스템이지만 패킷을 중재하는 부분은 가정, 회사의 LAN과 동일하다. 라우터의 기본적인 구조나 동작도 전혀 다르지 않다 가정이나 회사의 네트워크 규모가 커진 것이 인터넷 ✔️ 가정, 회사의 네트워크와 인터...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/os-study-08/" class="btn btn-outline-primary" prompt="Older"><p>[운영체제 스터디] 데드락과 데드락 발생조건 4가지</p></a> <a href="/posts/os-study-09/" class="btn btn-outline-primary" prompt="Newer"><p>[운영체제 스터디] 메모리 관리 - 논리적 주소와 물리적 주소</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/gzgzg2">박우람</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%EB%B0%98%ED%9A%A8%EA%B2%BD/">반효경</a> <a class="post-tag" href="/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80-%EC%A0%95%EB%B3%B4%EA%B8%B0%EC%88%A0%EC%9D%98-%EC%9B%90%EB%A6%AC/">운영체제와 정보기술의 원리</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/operating-system/">Operating System</a> <a class="post-tag" href="/tags/dns/">DNS</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/">운영체제</a> <a class="post-tag" href="/tags/%ED%86%A0%EB%B9%84%EC%9D%98-%EC%8A%A4%ED%94%84%EB%A7%81/">토비의 스프링</a> <a class="post-tag" href="/tags/gof/">Gof</a> <a class="post-tag" href="/tags/os/">OS</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
