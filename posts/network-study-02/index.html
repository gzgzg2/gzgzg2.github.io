<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.1" /><meta property="og:title" content="[네트워크 스터디] Chapter_02 TCP/IP의 데이터를 전기 신호로 만들어 보낸다" /><meta property="og:locale" content="en" /><meta name="description" content="📗 Chapter_02 TCP/IP의 데이터를 전기 신호로 만들어 보낸다 🌟 2장의 요점 짚고 넘어가기 🌟" /><meta property="og:description" content="📗 Chapter_02 TCP/IP의 데이터를 전기 신호로 만들어 보낸다 🌟 2장의 요점 짚고 넘어가기 🌟" /><link rel="canonical" href="https://gzgzg2.github.io//posts/network-study-02/" /><meta property="og:url" content="https://gzgzg2.github.io//posts/network-study-02/" /><meta property="og:site_name" content="일하는 냐옹이" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-04-29T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[네트워크 스터디] Chapter_02 TCP/IP의 데이터를 전기 신호로 만들어 보낸다" /><meta name="twitter:site" content="@none" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-04-29T00:00:00+09:00","datePublished":"2022-04-29T00:00:00+09:00","description":"📗 Chapter_02 TCP/IP의 데이터를 전기 신호로 만들어 보낸다 🌟 2장의 요점 짚고 넘어가기 🌟","headline":"[네트워크 스터디] Chapter_02 TCP/IP의 데이터를 전기 신호로 만들어 보낸다","mainEntityOfPage":{"@type":"WebPage","@id":"https://gzgzg2.github.io//posts/network-study-02/"},"url":"https://gzgzg2.github.io//posts/network-study-02/"}</script><title>[네트워크 스터디] Chapter_02 TCP/IP의 데이터를 전기 신호로 만들어 보낸다 | 일하는 냐옹이</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="일하는 냐옹이"><meta name="application-name" content="일하는 냐옹이"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/profile/navi_1.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">일하는 냐옹이</a></div><div class="site-subtitle font-italic">잠 자는게 좋아</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/gzgzg2" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/none" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['parkuram12','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[네트워크 스터디] Chapter_02 TCP/IP의 데이터를 전기 신호로 만들어 보낸다</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>[네트워크 스터디] Chapter_02 TCP/IP의 데이터를 전기 신호로 만들어 보낸다</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1651158000" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Apr 29, 2022 </em> </span> <span> Updated <em class="" data-ts="1651190400" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Apr 29, 2022 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://github.com/gzgzg2">박우람</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="6137 words"> <em>34 min</em> read</span></div></div></div><div class="post-content"><h1 id="-chapter_02-tcpip의-데이터를-전기-신호로-만들어-보낸다">📗 Chapter_02 TCP/IP의 데이터를 전기 신호로 만들어 보낸다</h1><h3 id="2장의-요점-짚고-넘어가기-"> <a href="#2장의-요점-짚고-넘어가기-" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 🌟 2장의 요점 짚고 넘어가기 🌟</h3><blockquote><p>Chapter 02에선 OS에 내장된 프로토콜 스택이 처음 등장한다. 프로토콜 스택은 네트워크 제어용 소프트웨어이다. 프로토콜 스택은 브라우저에서 받은 메세지를 패킷 속에 저장하고, 수신처 주소 등의 제어 정보를 덧붙인다. 프로토콜 스택은 통신 오류가 발생했을 때 패킷을 고쳐서 보내거나 통신의 기본을 조절하는 등의 다양한 역할을 한다.</p><p>이뿐만 아니라 프로토콜 스택은 패킷을 LAN어댑터(이더넷이나 무선 LAN으로 통신할 때 사용하는 하드웨어)에 넘긴다. 그리고 LAN 어댑터가 패킷을 전기신호로 변환하고 LAN의 케이블에 송출하는 과정을 통해 패킷이 네트워크 속으로 전달된다.</p></blockquote><h2 id="1-소켓을-작성한다"> <a href="#1-소켓을-작성한다" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> <strong>1. 소켓을 작성한다.</strong></h2><h3 id="1️⃣프로토콜-스택의-내부-구성"> <a href="#1️⃣프로토콜-스택의-내부-구성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> <strong>1️⃣ 프로토콜 스택의 내부 구성</strong></h3><p>아래 이미지는 브라우저에서 데이터를 전송했을 때 어떠한 소프트웨어와 하드웨어를 거쳐 서버에 도착하는 지</p><p>간단하게 요약한 이미지이다.</p><p><img data-src="https://user-images.githubusercontent.com/56028408/164371689-8ed7cd05-d86f-4853-bbb5-9d900e6b5ef0.png" alt="image" data-proofer-ignore></p><p><strong>✔️ 네트워크 어플리케이션</strong></p><ul><li>브라우저, 메일러, 웹 서버, 메일 서버 등의 프로그램이 여기에 해당됨<li>네트워크 어플리케이션부터 아래로 향하여 데이터 송 수신 등의 일을 의뢰함<li>Socket<ul><li>네트워크 애플리케이션 아랫부분에는 Socket 라이브러리가 존재하고 그 안에는 리졸버가 내장되어 있음<li>Socket 라이브러리는 DNS서버에서 목적지의 IP 주소를 조회하는 역할을 담당함</ul></ul><p><strong>✔️  프로토콜 스택</strong></p><ul><li>프로토콜 스택은 OS 내부에 존재하는 네트워크 제어용 소프트웨어이다.<li>TCP, UDP 프로토콜을 사용하는 소프트웨어<ul><li>프로토콜 스택의 윗부분에는 TCP, UDP 프로토콜을 사용하여 데이터 송수신을 담당하는 부분이 존재한다. 이 둘이 어플리케이션의 의뢰를 받아 송수신 동작을 실행한다.</ul><li>IP 프로토콜을 사용하는 소프트웨어<ul><li>데이터를 작게 나눈 패킷을 통신 상대까지 운반하는 것이 해당 소프트웨어의 주 역할<li>IP 안에는 ICMP와 ARP라는 프로토콜을 다루는 부분이 존재함<li>ICMP는 패킷을 운반할 때 발생하는 오류를 통지하거나 제어용 메세지를 통지할 때 사용됨<li>ARP는 IP 주소에 대응하는 이더넷의 MAC 주소를 조사할 때 사용됨</ul></ul><p><strong>✔️ LAN 드라이버</strong></p><ul><li>LAN 어댑터의 하드웨어를 제어함<li>LAN 드라이버 아래에 있는 LAN 어댑터가 실제 송 수신 동작, 즉 케이블에 대해 신호를 송 수신 하는 동작을 실행함</ul><div class="language-json highlighter-rouge"><div class="code-header"> <span data-label-text="JSON"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="err">💡 프로토콜</span><span class="w"> </span><span class="err">스택이란</span><span class="w"> </span><span class="err">네트워크</span><span class="w"> </span><span class="err">제어용</span><span class="w"> </span><span class="err">소프트웨어이다.</span><span class="w"> </span><span class="err">프로토콜</span><span class="w"> </span><span class="err">스택은</span><span class="w"> </span><span class="err">제어</span><span class="w"> </span><span class="err">정보를</span><span class="w"> </span><span class="err">저장하거나</span><span class="w"> </span><span class="err">패킷을</span><span class="w"> </span><span class="err">LAN</span><span class="w"> </span><span class="err">어댑터에</span><span class="w"> </span><span class="err">넘기는</span><span class="w"> </span><span class="err">역할을</span><span class="w"> </span><span class="err">담당한다.</span><span class="w">

</span><span class="err">💡 브라우저나</span><span class="w"> </span><span class="err">메일</span><span class="w"> </span><span class="err">등의</span><span class="w"> </span><span class="err">일반적인</span><span class="w"> </span><span class="err">애플리케이션이</span><span class="w"> </span><span class="err">데이터를</span><span class="w"> </span><span class="err">송</span><span class="w"> </span><span class="err">수신할</span><span class="w"> </span><span class="err">경우에는</span><span class="w"> </span><span class="err">TCP를</span><span class="w"> </span><span class="err">주로</span><span class="w"> </span><span class="err">사용</span><span class="w">

</span><span class="err">💡 DNS</span><span class="w"> </span><span class="err">서버에</span><span class="w"> </span><span class="err">대한</span><span class="w"> </span><span class="err">조회</span><span class="w"> </span><span class="err">등에서</span><span class="w"> </span><span class="err">짧은</span><span class="w"> </span><span class="err">제어용</span><span class="w"> </span><span class="err">데이터를</span><span class="w"> </span><span class="err">송수신할</span><span class="w"> </span><span class="err">경우에는</span><span class="w"> </span><span class="err">UDP 사용</span><span class="w">
</span></pre></table></code></div></div><p><strong>✔️  소켓의 메세지 송신 동작</strong>  </p><p><img data-src="https://user-images.githubusercontent.com/56028408/164371702-c3a06672-64e0-4ee6-8419-da6472697a41.png" alt="image" data-proofer-ignore></p><h3 id="2️⃣소켓의-실체는-통신-제어용-제어-정보"> <a href="#2️⃣소켓의-실체는-통신-제어용-제어-정보" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 2️⃣ 소켓의 실체는 통신 제어용 제어 정보</h3><p>프로토콜 스택은 내부에 제어 정보를 기록하는 메모리 영역을 가지고 있다. 해당 영역에는 통신 동작 제어에 필요한 제어 정보를 기록한다. 대표적으로 <strong>통신 상대의 IP주소, 포트번호, 통신 동작 진행 상태</strong> 등이 있다.</p><p>본래 소켓은 개념적인 것이고 실체가 존재하지 않는다. 굳이 말하자면 프로토콜 스택 내부에 저장된 제어 정보가 소켓의 실체라고 할 수 있다. 프로토콜 스택은 소켓에 기록된 제어 정보를 참조하면서 동작한다.</p><h3 id="3️⃣소켓을-호출했을-때의-동작"> <a href="#3️⃣소켓을-호출했을-때의-동작" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 3️⃣ 소켓을 호출했을 때의 동작</h3><p><strong>✔️  socket()</strong></p><ul><li>애플리케이션이 socket을 호출하여 프로토콜 스택에게 소켓을 만들 것을 의뢰한다. 이때 프로토콜 스택은 소켓 한 개 분량의 메모리 영역을 확보하고 초기 상태임을 나타내는 제어 정보를 기록한다. 이 과정을 통해 소켓이 생성된다.<li>소켓이 생성되면 소켓을 나타내는 디스크립터를 애플리케이션에 알려준다. 디스크립터는 프로토콜 스택의 내부에 있는 다수의 소켓 중 어느 것을 가리키는지 나타내는 번호표와 같다. 디스크립터는 프로토콜 스택이 데이터 송 수신 동작을 의뢰할 때 통지한다.</ul><h2 id="2-서버에-접속한다"> <a href="#2-서버에-접속한다" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 2. 서버에 접속한다.</h2><h3 id="1️⃣접속의-의미"> <a href="#1️⃣접속의-의미" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> <strong>1️⃣</strong>  접속의 의미</h3><blockquote><p>이더넷이나 통신 회선은 항상 케이블이 연결되어 있으므로 데이터를 신호로 변환하여 송신하기만 하면 언제든 통신이 가능하다. 하지만 소켓을 만든 직후에는 아무런 정보도 기록되어 있지 않기 때문에 통신 상대와의 사이에 제어 정보를 주고받아서 데이터 송 수신이 가능한 상태로 만드는 작업이 필요하다. 여기에서 주고받는 제어정보는 IP나 포트번호 등이다. 접속 동작에서 주고받는 제어 정보는 통신의 규칙으로 정해져 있다.</p><p>접속을 시도할 때는 제어 정보를 주고받는 것 뿐만 아니라 송 수신 데이터를 일시적으로 저장할 버퍼 메모리 확보도 이때 같이 실행된다.</p></blockquote><h3 id="2️⃣맨-앞부분에-제어-정보를-기록한-헤더를-배치한다"> <a href="#2️⃣맨-앞부분에-제어-정보를-기록한-헤더를-배치한다" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 2️⃣ 맨 앞부분에 제어 정보를 기록한 헤더를 배치한다.</h3><p><strong>✔️  헤더란?</strong> </p><ul><li>헤더는 클라이언트와 서버가 서로 연락을 절충하기 위해 주고받는 정보가 포함되어 있다.<li>헤더에는 데이터를 송 수신 하는 동작이나 연결을 끊는 동작도 포함되어 있기 때문에 통신 동작 전체에서 필요한 내용을 검토하여 TCP 프로토콜의 사양으로 규정하고 있다.<li>클라이언트와 서버 사이에 주고받는 패킷 맨 앞부분부터 부가된 제어정보를 헤더라고 한다.<li>이더넷이나 IP에도 동일한 헤더가 존재하기 때문에 <strong>TCP 헤더, 이더넷 헤더(=Mac 헤더), IP헤더</strong>와 같이 구분하여 사용해야 한다.</ul><p><strong>✔️  소켓에 기록되는 정보</strong></p><ul><li>프로토콜 스택의 동작을 제어하기 위한 정보<ul><li>애플리케이션에서 통지된 정보<li>통신 상대로부터 받은 정보<li>송 수신 동작의 진행 상황</ul><li>프로토콜 스택이 소켓에 기록된 정보를 참조하면서 움직이기 때문에 소켓의 제어 정보는 프로토콜 스택과 일체화 되어있다 해도 무방하다.<li>소켓에 기록되는 정보는 상대측에서 볼 수 없다. 이미 서로 필요한 정보를 헤더로 주고받기 때문에 통신에는 문제가 없다.</ul><div class="language-json highlighter-rouge"><div class="code-header"> <span data-label-text="JSON"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="err">🌟 </span><span class="w"> </span><span class="err">통신</span><span class="w"> </span><span class="err">동작에</span><span class="w"> </span><span class="err">이용하는</span><span class="w"> </span><span class="err">제어</span><span class="w"> </span><span class="err">정보는</span><span class="w"> </span><span class="err">다음의</span><span class="w"> </span><span class="err">두</span><span class="w"> </span><span class="err">종류</span><span class="w">

</span><span class="mi">1</span><span class="err">.</span><span class="w"> </span><span class="err">헤더에</span><span class="w"> </span><span class="err">기입되는</span><span class="w"> </span><span class="err">정보</span><span class="w">
</span><span class="mi">2</span><span class="err">.</span><span class="w"> </span><span class="err">소켓에</span><span class="w"> </span><span class="err">기록되는</span><span class="w"> </span><span class="err">정보</span><span class="w">
</span></pre></table></code></div></div><h3 id="3️⃣접속-동작의-실체"> <a href="#3️⃣접속-동작의-실체" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 3️⃣ 접속 동작의 실체</h3><p><strong>✔️ connet()</strong></p><ul><li>여기에 서버측의 IP 주소와 포트 번호를 입력하면 명령이 프로토콜 스택의 TCP 담당 부분에 전달된다.<li>그러면 TCP 담당 부분은 목적지 서버측의 TCP 담당 부분과의 사이에 제어 정보를 주고 받는다.</ul><p><strong>✔️  클라이언트와 서버의 대화 과정</strong> </p><div class="language-json highlighter-rouge"><div class="code-header"> <span data-label-text="JSON"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="mi">1</span><span class="err">.</span><span class="w"> </span><span class="err">데이터</span><span class="w"> </span><span class="err">송</span><span class="w"> </span><span class="err">수신</span><span class="w"> </span><span class="err">동작의</span><span class="w"> </span><span class="err">개시를</span><span class="w"> </span><span class="err">나타내는</span><span class="w"> </span><span class="err">제어</span><span class="w"> </span><span class="err">정보를</span><span class="w"> </span><span class="err">기록한</span><span class="w"> </span><span class="err">헤더를</span><span class="w"> </span><span class="err">만든다.</span><span class="w">
    </span><span class="mi">1</span><span class="err">.</span><span class="w"> </span><span class="err">헤더의</span><span class="w"> </span><span class="err">내용</span><span class="w"> </span><span class="err">중</span><span class="w"> </span><span class="err">중요한</span><span class="w"> </span><span class="err">것은</span><span class="w"> </span><span class="err">송신처와</span><span class="w"> </span><span class="err">수신처의</span><span class="w"> </span><span class="err">포트번호이다.</span><span class="w"> </span><span class="err">이를</span><span class="w"> </span><span class="err">통해</span><span class="w"> </span><span class="err">송신처와</span><span class="w"> </span><span class="err">수신처를</span><span class="w"> </span><span class="err">지정할</span><span class="w"> </span><span class="err">수</span><span class="w"> </span><span class="err">있다.</span><span class="w">
    
</span><span class="mi">2</span><span class="err">.</span><span class="w"> </span><span class="err">TCP</span><span class="w"> </span><span class="err">헤더가</span><span class="w"> </span><span class="err">만들어지면</span><span class="w"> </span><span class="err">이를</span><span class="w"> </span><span class="err">IP</span><span class="w"> </span><span class="err">담당</span><span class="w"> </span><span class="err">소프트웨어에</span><span class="w"> </span><span class="err">건네주어</span><span class="w"> </span><span class="err">송신하도록</span><span class="w"> </span><span class="err">의뢰한다.</span><span class="w">

</span><span class="mi">3</span><span class="err">.</span><span class="w"> </span><span class="err">송신</span><span class="w"> </span><span class="err">동작을</span><span class="w"> </span><span class="err">거쳐</span><span class="w"> </span><span class="err">네트워크를</span><span class="w"> </span><span class="err">통해</span><span class="w"> </span><span class="err">서버에</span><span class="w">  </span><span class="err">패킷이</span><span class="w"> </span><span class="err">도착하면</span><span class="w"> </span><span class="err">서버측의</span><span class="w"> </span><span class="err">IP</span><span class="w"> </span><span class="err">담당</span><span class="w"> </span><span class="err">소프트웨어가</span><span class="w"> </span><span class="err">이를</span><span class="w"> </span><span class="err">TCP</span><span class="w"> </span><span class="err">담당</span><span class="w"> </span><span class="err">소프트웨어</span><span class="w"> </span><span class="err">에게</span><span class="w"> </span><span class="err">전달한다.</span><span class="w">

</span><span class="mi">4</span><span class="err">.</span><span class="w"> </span><span class="err">서버측의</span><span class="w"> </span><span class="err">TCP</span><span class="w"> </span><span class="err">담당</span><span class="w"> </span><span class="err">소프트웨어가</span><span class="w"> </span><span class="err">TCP헤더를</span><span class="w"> </span><span class="err">조사하여</span><span class="w"> </span><span class="err">기록되어</span><span class="w"> </span><span class="err">있는</span><span class="w"> </span><span class="err">수신처</span><span class="w"> </span><span class="err">포트</span><span class="w"> </span><span class="err">번호에</span><span class="w"> </span><span class="err">해당하는</span><span class="w"> </span><span class="err">소켓을</span><span class="w"> </span><span class="err">찾아낸다.</span><span class="w"> 
   </span><span class="err">해당하는</span><span class="w"> </span><span class="err">소켓이</span><span class="w"> </span><span class="err">발견되면</span><span class="w"> </span><span class="err">해당</span><span class="w"> </span><span class="err">소켓에</span><span class="w"> </span><span class="err">필요한</span><span class="w"> </span><span class="err">정보를</span><span class="w"> </span><span class="err">기록하고</span><span class="w"> </span><span class="err">접속</span><span class="w"> </span><span class="err">동작</span><span class="w"> </span><span class="err">상태를</span><span class="w"> </span><span class="err">진행</span><span class="w"> </span><span class="err">중으로</span><span class="w"> </span><span class="err">변경한다.</span><span class="w">
    
</span><span class="mi">5</span><span class="err">.</span><span class="w"> </span><span class="err">(</span><span class="mi">4</span><span class="err">)번</span><span class="w"> </span><span class="err">과정이</span><span class="w"> </span><span class="err">끝나면</span><span class="w"> </span><span class="err">서버의</span><span class="w"> </span><span class="err">TCP</span><span class="w"> </span><span class="err">담당</span><span class="w"> </span><span class="err">소프트웨어는</span><span class="w"> </span><span class="err">응답을</span><span class="w"> </span><span class="err">돌려보내기</span><span class="w"> </span><span class="err">위해</span><span class="w"> </span><span class="err">IP</span><span class="w"> </span><span class="err">담당</span><span class="w"> </span><span class="err">소프트웨어에게</span><span class="w"> </span><span class="err">의뢰한다.</span><span class="w"> 

</span><span class="mi">6</span><span class="err">.</span><span class="w"> </span><span class="err">이때</span><span class="w"> </span><span class="err">ACK라는</span><span class="w"> </span><span class="err">컨트롤</span><span class="w"> </span><span class="err">비트도</span><span class="w"> </span><span class="mi">1</span><span class="err">로</span><span class="w"> </span><span class="err">설정하여</span><span class="w"> </span><span class="err">돌려보낸다.</span><span class="w"> 

</span><span class="mi">7</span><span class="err">.</span><span class="w"> </span><span class="err">패킷이</span><span class="w"> </span><span class="err">클라이언트에게</span><span class="w"> </span><span class="err">정상적으로</span><span class="w"> </span><span class="err">돌아왔으면</span><span class="w"> </span><span class="err">TCP</span><span class="w"> </span><span class="err">헤더를</span><span class="w"> </span><span class="err">조사하여</span><span class="w"> </span><span class="err">서버측의</span><span class="w"> </span><span class="err">접속</span><span class="w"> </span><span class="err">동작이</span><span class="w"> </span><span class="err">성공했는</span><span class="w"> </span><span class="err">지</span><span class="w"> </span><span class="err">확인한다.</span><span class="w"> 
   </span><span class="err">서버</span><span class="w"> </span><span class="err">측의</span><span class="w"> </span><span class="err">접속이</span><span class="w"> </span><span class="err">성공했으면</span><span class="w"> </span><span class="err">클라이언트</span><span class="w"> </span><span class="err">소켓에</span><span class="w"> </span><span class="err">서버</span><span class="w"> </span><span class="err">IP</span><span class="w"> </span><span class="err">주소나</span><span class="w"> </span><span class="err">포트</span><span class="w"> </span><span class="err">번호</span><span class="w"> </span><span class="err">등과</span><span class="w"> </span><span class="err">함께</span><span class="w"> </span><span class="err">접속</span><span class="w"> </span><span class="err">완료를</span><span class="w"> </span><span class="err">나타내는</span><span class="w"> </span><span class="err">제어</span><span class="w"> </span><span class="err">정보를</span><span class="w"> </span><span class="err">기록한다.</span><span class="w">
    
</span><span class="mi">8</span><span class="err">.</span><span class="w"> </span><span class="err">마지막으로</span><span class="w"> </span><span class="err">클라이언트에</span><span class="w"> </span><span class="err">패킷이</span><span class="w"> </span><span class="err">정상적으로</span><span class="w"> </span><span class="err">도착했다는</span><span class="w"> </span><span class="err">것을</span><span class="w"> </span><span class="err">알리기</span><span class="w"> </span><span class="err">위해</span><span class="w"> </span><span class="err">ACK</span><span class="w"> </span><span class="err">비트를</span><span class="w"> </span><span class="mi">1</span><span class="err">로</span><span class="w"> </span><span class="err">만든</span><span class="w"> </span><span class="err">TCP</span><span class="w"> </span><span class="err">헤더를</span><span class="w"> </span><span class="err">서버측에</span><span class="w"> </span><span class="err">반송한다.</span><span class="w">
</span></pre></table></code></div></div><p><strong>🌟 ACK는 패킷이 대상에게 잘 도착했는지 확인하는 용도로 사용된다.</strong></p><h2 id="3-데이터를-송수신-한다"> <a href="#3-데이터를-송수신-한다" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 3. 데이터를 송수신 한다.</h2><h3 id="1️⃣프로토콜-스택에--http-리퀘스트-메세지를-넘긴다"> <a href="#1️⃣프로토콜-스택에--http-리퀘스트-메세지를-넘긴다" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> <strong>1️⃣ 프로토콜 스택에 HTTP 리퀘스트 메세지를 넘긴다.</strong></h3><blockquote><p>connect에서 애플리케이션에 제어가 되돌아오면 데이터 송 수신 동작이 들어간다. 데이터 송 수신 동작은 애플리케이션이 <strong>✔️ write()</strong> 를 호출하여 송신 데이터를 프로토콜 스택에 건네주는 곳부터 시작된다.</p></blockquote><p>프로토콜 스택은 받은 데이터의 내용을 곧바로 송신하는 것이 아니라 일단 프로토콜 스택 내부의 송신용 버퍼 메모리 영역에 저장하고 애플리케이션이 다음 데이터를 건네주기를 기다린다.</p><p>송신용 버퍼에 저장하는 이유는 애플리케이션에서 프로토콜 스택에 건네주는 데이터의 길이는 애플리케이션마다 상이하기 때문이다. 이러한 상황에서 받은 데이터를 곧바로 보내는 방법은 작은 패킷을 많이 보낼 수 있지만 네트워크 이용 효율이 저하되므로 어느 정도 데이터를 저장하고 나서 송 수신 동작을 진행한다.</p><p>송신 버퍼에 어느 정도의 데이터가 담겼을 때 송신한다는 규칙은 OS의 종류나 버전마다 달라지지만 <strong>MTU</strong>나 <strong>타이밍</strong>을 바탕으로 어느정도 판단할 수 있다.</p><p><strong>✔️ MTU?</strong></p><ul><li>한 패킷으로 운반할 수 있는 디지털 데이터의 최대 길이 이더넷에서는 보통 1500 바이트<li>MTU에는 패킷의 맨 앞부분에 헤더가 포함되어 있음, 여기부터 헤더를 제외한 것이 하나의 패킷으로 운반할 수 있는 데이터의 최대 길이가 됨 이것을 <strong>MSS</strong> 라고 한다.</ul><p><strong>✔️ MSS?</strong></p><ul><li>헤더를 제외하고 한 개의 패킷으로 운반할 수 있는 TCP의 데이터 최대 길이<li>애플리케이션에서 받은 데이터가 MSS를 초과하거나 MSS에 가까운 길이에 이르기까지 데이터를 저장하고 송신동작을 진행하면 패킷이 잘게 나눠질 걱정을 하지 않아도 된다.</ul><p><img data-src="https://user-images.githubusercontent.com/56028408/164371712-2c075fc2-7133-48aa-837b-c3bf552b4f15.png" alt="image" data-proofer-ignore></p><p>✔️ <strong>타이밍?</strong></p><p>애플리케이션의 송신 속도가 느려지는 경우 MSS에 가깝게 데이터를 저장하면 여기에서 시간이 걸려 송신 동작이 지연되므로 버퍼에 데이터가 모이지 않아도 적당한 곳에서 송신 동작을 실행해야 한다. 따라서 프로토콜 스택은 일정한 시간이 경과하면 패킷을 송신할 수 있게 내부에 타이머라는 소프트웨어를 둔다.</p><p>두 가지의 판단요소가 존재하지만 이 둘은 상반되는 면도 존재한다. <strong>MSS</strong> 바탕을 중시하면 패킷 길이가 길어져서 네트워크 이용 효율이 높아지지만 버퍼에 머무는 시간만큼 송신 동작이 지연될 우려가 존재한다. 반대로 타이밍을 중시하면 지연은 적어지지만 이용 효율이 떨어지므로 양자를 절충해서 적당히 시간을 가늠하여 송신 동작을 실행해야 한다. 그러나 TCP 프로토콜 사양에는 절충에 대한 규약은 없으므로 실제 판단은 프로토콜 스택을 만드는 개발자의 몫이다.</p><h3 id="2️⃣데이터가-클-때는-분할하여-보낸다"> <a href="#2️⃣데이터가-클-때는-분할하여-보낸다" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 2️⃣ 데이터가 클 때는 분할하여 보낸다</h3><p>HTTP 리퀘스트 메세지는 보통 그다지 길지 않은 것이 대부분이다. 하지만 항상 예외는 존재하기에 HTTP 리퀘스트 메세지가 한 개의 패킷에 전부 들어가지 못할 경우, 송신 버퍼에 들어있는 데이터를 맨 앞부터 차례대로 MSS의 크기에 맞게 분할하고 분할한 조각을 한 개씩 패킷에 넣어 송신한다.</p><p><img data-src="https://user-images.githubusercontent.com/56028408/164371676-1c0fa15f-f6bb-4a7d-8df4-77c61fdae138.png" alt="image" data-proofer-ignore></p><h3 id="3️⃣-ack-번호를-사용하여-패킷이-도착했는지-확인한다"> <a href="#3️⃣-ack-번호를-사용하여-패킷이-도착했는지-확인한다" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 3️⃣  ACK 번호를 사용하여 패킷이 도착했는지 확인한다.</h3><p>데이터 송신동작은 앞서 설명한 것 만으로는 끝나지 않는다. TCP는 송신한 패킷이 상대에게 도착했는지 확인하고 도착하지 않았으면 다시 송신하는 기능이 있으므로 패킷을 송신한 후에는 확인 동작으로 넘어간다.</p><p>먼저 TCP 담당 소프트웨어는 데이터를 조각으로 분할할 때 조각이 통신 개시부터 따져서 몇 번째 바이트에 해당 하는지 세어둔다. 이 값을 시퀀스 번호라고 하며 TCP 헤더에 기록한다. 이렇게 시퀀스 번호를 기록할 경우 수신측에서 패킷의 누락여부를 확인할 수 있다. 수신측은 전달 받은 데이터의 바이트 크기를 확인하고 이를 ACK 번호에 기록하고 이 값에 1을 더하여 송신측에 전달한다.</p><p>✔️ <strong>예시</strong></p><p>총 4381바이트의 데이터를 전송한다고 가정한다.</p><p><strong>[누락되지 않은 경우]</strong></p><ol><li>시퀀스 번호 1 , 데이터 크기 : 1460바이트<ol><li>ACK 번호 1461</ol><li>시퀀스 번호 1461, 데이터 크기 : 1460바이트<ol><li>ACK 번호 2921</ol><li>시퀀스 번호 2921, 데이터 크기 : 1460바이트<ol><li>ACK 번호 4381</ol></ol><p><strong>[누락된 경우]</strong></p><ol><li>시퀀스 번호 1 , 데이터 크기 : 1460바이트<ol><li>ACK 번호 1461</ol><li>시퀀스 번호 1461, 데이터 크기 : 1460바이트<ol><li>ACK 번호 전송하지 않음</ol><li>시퀀스 번호 1461, 데이터 크기 : 1460바이트 (재전송)<ol><li>ACK 번호 2921</ol></ol><div class="language-json highlighter-rouge"><div class="code-header"> <span data-label-text="JSON"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="err">🌟 </span><span class="w"> </span><span class="err">시퀀스</span><span class="w"> </span><span class="err">번호와</span><span class="w"> </span><span class="err">ACK</span><span class="w"> </span><span class="err">번호로</span><span class="w"> </span><span class="err">패킷이</span><span class="w"> </span><span class="err">수신측에</span><span class="w"> </span><span class="err">도착한</span><span class="w"> </span><span class="err">것을</span><span class="w"> </span><span class="err">확인한다.</span><span class="w">

</span><span class="err">🌟 ACK</span><span class="w"> </span><span class="err">번호를</span><span class="w"> </span><span class="err">통지할</span><span class="w"> </span><span class="err">때는</span><span class="w"> </span><span class="err">단순히</span><span class="w"> </span><span class="err">ACK</span><span class="w"> </span><span class="err">번호에</span><span class="w"> </span><span class="err">값을</span><span class="w"> </span><span class="err">설정할</span><span class="w"> </span><span class="err">뿐만</span><span class="w"> </span><span class="err">아니라</span><span class="w"> </span><span class="err">제어</span><span class="w"> </span><span class="err">비트의</span><span class="w"> </span><span class="err">ACK</span><span class="w"> </span><span class="err">비트도</span><span class="w"> </span><span class="mi">1</span><span class="err">로</span><span class="w"> </span><span class="err">설정한다.</span><span class="w"> 
</span><span class="err">이렇게하면</span><span class="w"> </span><span class="err">ACK</span><span class="w"> </span><span class="err">번호</span><span class="w"> </span><span class="err">필드가</span><span class="w"> </span><span class="err">유효하다는</span><span class="w"> </span><span class="err">의미가</span><span class="w"> </span><span class="err">된다.</span><span class="w">
</span></pre></table></code></div></div><h3 id="4️⃣-패킷-평균-왕복-시간으로-ack-번호의-대기-시간을-조정한다"> <a href="#4️⃣-패킷-평균-왕복-시간으로-ack-번호의-대기-시간을-조정한다" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> <strong>4️⃣  패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다.</strong></h3><p>ACK 번호가 돌아오는 것을 기다리는 시간을 <strong>타임아웃 값</strong> 이라고 한다.</p><p>네트워크가 혼잡하면 ACK 번호가 돌아오는 시간이 지연될 수 있다. 이때 ACK 번호가 돌아오기전에 패킷을 재전송하면 혼잡한 네트워크를 악화시키는 사태가 발생한다.</p><p>이러한 문제를 방지하기 위해 대기 시간을 적절하게 설정해야한다. 대기 시간이 너무 짧으면 패킷을 자주 보내게 되고 대기시간을 너무 길게 설정하면 패킷을 다시 보내는 동작이 지연되어 속도 저하의 원인이 되기 때문이다.</p><p>보통 TCP는 ACK 번호가 돌아오는 시간을 기준으로 대기 시간을 판단하여 동적으로 변경하는 방법을 취한다.</p><h3 id="5️⃣-윈도우-제어-방식으로-효율적으로-ack-번호를-관리한다"> <a href="#5️⃣-윈도우-제어-방식으로-효율적으로-ack-번호를-관리한다" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> <strong>5️⃣  윈도우 제어 방식으로 효율적으로 ACK 번호를 관리한다.</strong></h3><p>ACK 번호가 돌아올 때까지의 시간동안 아무 일도 하지 않고 기다리는 것은 자원과 시간 낭비이다.</p><p>낭비를 줄이기 위해 TCP는 윈도우 제어 방식에 따라 송신과 ACK 번호 통지의 동작을 실행한다.</p><p>윈도우 제어 방식이란 한 개의 패킷을 보낸 후 ACK 번호를 기다리지 않고 차례대로 연속해서 복수의 패킷을 보내는 방법을 말한다. 이럴 경우 ACK 번호가 돌아올 때까지의 시간이 낭비되지 않는다.</p><p>주의할 점은 ACK 번호를 기다리지 않고 차례로 패킷을 보내면 수신측의 능력을 초과하여 패킷을 보내는 사태가 발생할 수 있다.</p><p>수신측은 패킷을 수신하면 수신측 버퍼 메모리에 일시 보관한다. 수신측에서는 ACK 번호를 계산하는 작업이나 조각을 연결하여 원래 데이터를 복원하고 애플리케이션에 넘겨주어야 수신 버퍼에 저장된 데이터가 사용되어 사라진다. 하지만 송신측이 수신측의 처리속도보다 빠른 속도로 패킷을 송신하면 수신 버퍼에 데이터가 쌓이지 않고 사라질 수 있다.</p><p>이러한 문제를 방지하기 위해 수신측은 송신측에 수신가능한 데이터의 양을 통지한다. 수신 가능한 양은 TCP 헤더의 윈도우 필드에 기록하여 송신측에 알린다.</p><h3 id="6️⃣ack-번호와-윈도우를-합승한다"> <a href="#6️⃣ack-번호와-윈도우를-합승한다" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> <strong>6️⃣ ACK 번호와 윈도우를 합승한다.</strong></h3><p>수신측은 네트워크 효율성 저하를 방지하기 위해 ACK 번호나 윈도우를 통지할 때 소켓을 바로 보내지 않고 잠시 기다린다. 기다리는 사이에 통지 동작이 발생하면 양쪽을 상승시켜서 한 개의 패킷으로 묶어서 전송한다.</p><p>예를 들자면 ACK 번호의 송신을 대조할 때 윈도우 통지가 발생하면 ACK 번호와 윈도우를 한개의 패킷에 합승 시켜서 통지하여 패킷의 수를 줄이는 것이다.</p><p>연속으로 ACK 번호 통지가 발생할 때도 마찬가지다. ACK 번호는 수신한 데이터의 끝이 어디인지를 송신측에 알리는 것이므로 ACK 번호가 통지가 연속적으로 발생하면 마지막 ACK 번호만 송신하고 나머지의 것은 생략해도 상관없다. 윈도우 통지도 마찬가지이다. 윈도우 통지가 연속적으로 발생하면 수신버퍼에 빈 공간이 늘어난다는 의미이므로 마지막 통지만 전달해도 문제가 발생하지 않는다.</p><h3 id="7️⃣http-응답-메세지를-수신한다"> <a href="#7️⃣http-응답-메세지를-수신한다" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> <strong>7️⃣ HTTP 응답 메세지를 수신한다.</strong></h3><p>HTTP 리퀘스트 메세지를 보내면 웹 서버에서 응답 메세지가 돌아오기를 기다리고, 응답 메세지가 돌아오면 그것을 수신한다.</p><p>데이터를 수신하면 수신한 데이터 조각과 TCP 헤더의 내용을 조사하여 누락된 데이터가 있는 지 검사하고 문제가 없으면 송신측에 ACK 번호를 반송한다. 그리고 데이터의 조각을 수신 버퍼에 일시 보관하고 데이터 조각을 연결하여 애플리케이션에게 건네준다. 이를 정확하게 설명하자면 수신 버퍼에 저장된 데이터를 애플리케이션 메모리 영역에 옮기고 제어권을 애플리케이션에게 되돌려준다.</p><h2 id="4-서버에서-연결을-끊어-소켓을-말소한다"> <a href="#4-서버에서-연결을-끊어-소켓을-말소한다" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 4. 서버에서 연결을 끊어 소켓을 말소한다.</h2><h3 id="1️⃣데이터-보내기를-완료했을-때-연결을-끊는다"> <a href="#1️⃣데이터-보내기를-완료했을-때-연결을-끊는다" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> <strong>1️⃣ 데이터 보내기를 완료했을 때 연결을 끊는다.</strong></h3><p>데이터의 송 수신 동작이 완료되면 대상과의 연결을 끊는다. 이때 연결 끊기를 시도하는 대상은 서버나 클라이언트의 구분이 없다. 만약 서버에서 먼저 연결을 끊는다고 가정하면 서버측의 프로토콜 스택이 TCP 헤더를 생성하고 컨트롤비트인 FIN의 값을 1로 설정하여 클라이언트에게 전송한다. 이때 서버측은 소켓이 연결 끊기 동작에 들어갔다는 것을 기록한다. 서버에서 FIN을 설정한 TCP 헤더가 클라이언트에게 도착하면 클라이언트는 자신의 소켓에 서버가 연결끊기 작업에 들어갔다는 것을 기록하고 서버측에 FIN 값을 수신했다는 의미로 ACK 값을 전송한다.</p><p>클라이언트측 소켓이 애플리케이션에 데이터를 전부 전달하면 클라이언트측의 애플리케이션도 close를 호출하여 데이터 송 수신 동작을 중지한다. 그러면 클라이언트의 프로토콜 스택도 서버와 마찬가지로 TCP 헤더에 FIN 값을 1로 설정하여 서버측에 전송한다. 서버측에서 ACK 값이 되돌아오면 서버와의 대화는 끝이난 것이다.</p><p><strong>[연결 끊기 동작]</strong></p><ol><li>클라이언트가 FIN 송신<li>서버가 ACK 번호 송신<li>서버가 FIN 송신<li>클라이언트가 ACK 번호 송신</ol><p><strong>🌟  이때 연결 종료의 순서는 클라이언트와 서버가 서로 바뀔수도 있다.</strong> </p><h3 id="2️⃣소켓을-말소한다"> <a href="#2️⃣소켓을-말소한다" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 2️⃣ 소켓을 말소한다.</h3><p>서버와의 대화가 끝나면 더이상 소켓을 사용하여 서버와 대화할 수 없다. 하지만 이때 바로 소켓을 말소시키면 ACK 번호의 응답이 늦어 FIN을 재전송 할 때 기록 정보가 제거되어 어느 소켓이 수신 대상인지 알 수 없게 된다. 뿐만아니라 동일한 포트로 새롭게 생성된 소켓이 FIN을 수신하여 오동작이 발생할 수 있다. 이러한 문제 때문에 소켓을 바로 말소하지 않고 일정시간 기다린 후 말소한다.</p><p><br /> <br /></p><h1 id="reference">Reference</h1><p><a href="https://velog.io/@anhesu11/HTTP-%EA%B8%B0%EB%B3%B8-%EC%9D%B4%EB%A1%A0-%EC%A0%95%EB%A6%AC">https://velog.io/@anhesu11/HTTP-기본-이론-정리</a></p><p>성공과 실패를 결정하는 1%의 네트워크</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/networkstudy/'>networkStudy</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/3-way-handshake/" class="post-tag no-text-decoration" >3 way handshake</a> <a href="/tags/4-way-handshake/" class="post-tag no-text-decoration" >4 way handshake</a> <a href="/tags/socket/" class="post-tag no-text-decoration" >Socket</a> <a href="/tags/dns/" class="post-tag no-text-decoration" >DNS</a> <a href="/tags/tcp/" class="post-tag no-text-decoration" >TCP</a> <a href="/tags/%EC%84%B1%EA%B3%B5%EA%B3%BC-%EC%8B%A4%ED%8C%A8%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-1-%EC%9D%98-%EC%9B%90%EB%A6%AC/" class="post-tag no-text-decoration" >성공과 실패를 위한 네트워크 1%의 원리</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%5B%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC+%EC%8A%A4%ED%84%B0%EB%94%94%5D+Chapter_02+TCP%2FIP%EC%9D%98+%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC+%EC%A0%84%EA%B8%B0+%EC%8B%A0%ED%98%B8%EB%A1%9C+%EB%A7%8C%EB%93%A4%EC%96%B4+%EB%B3%B4%EB%82%B8%EB%8B%A4+-+%EC%9D%BC%ED%95%98%EB%8A%94+%EB%83%90%EC%98%B9%EC%9D%B4&url=https%3A%2F%2Fgzgzg2.github.io%2F%2Fposts%2Fnetwork-study-02%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%5B%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC+%EC%8A%A4%ED%84%B0%EB%94%94%5D+Chapter_02+TCP%2FIP%EC%9D%98+%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC+%EC%A0%84%EA%B8%B0+%EC%8B%A0%ED%98%B8%EB%A1%9C+%EB%A7%8C%EB%93%A4%EC%96%B4+%EB%B3%B4%EB%82%B8%EB%8B%A4+-+%EC%9D%BC%ED%95%98%EB%8A%94+%EB%83%90%EC%98%B9%EC%9D%B4&u=https%3A%2F%2Fgzgzg2.github.io%2F%2Fposts%2Fnetwork-study-02%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fgzgzg2.github.io%2F%2Fposts%2Fnetwork-study-02%2F&text=%5B%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC+%EC%8A%A4%ED%84%B0%EB%94%94%5D+Chapter_02+TCP%2FIP%EC%9D%98+%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC+%EC%A0%84%EA%B8%B0+%EC%8B%A0%ED%98%B8%EB%A1%9C+%EB%A7%8C%EB%93%A4%EC%96%B4+%EB%B3%B4%EB%82%B8%EB%8B%A4+-+%EC%9D%BC%ED%95%98%EB%8A%94+%EB%83%90%EC%98%B9%EC%9D%B4" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div><script src="https://utteranc.es/client.js" repo="gzgzg2/blog-comments" issue-term="pathname" label="Comment🐱" theme="github-light" crossorigin="anonymous" async> </script></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/strategy-pattern/">[Java Design Pattern] Strategy Pattern</a><li><a href="/posts/http2/">HTTP/2</a><li><a href="/posts/toby-spring-chapter-2/">[토비의 스프링] 토비의 스프링 3.1 2장 테스트</a><li><a href="/posts/toby-spring-chapter-1/">[토비의 스프링] 토비의 스프링 3.1 1장 오브젝트와 의존관계</a><li><a href="/posts/spring-applicationcontext/">SpringFramework - Web ApplicationContext</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%EB%B0%98%ED%9A%A8%EA%B2%BD/">반효경</a> <a class="post-tag" href="/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80-%EC%A0%95%EB%B3%B4%EA%B8%B0%EC%88%A0%EC%9D%98-%EC%9B%90%EB%A6%AC/">운영체제와 정보기술의 원리</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/operating-system/">Operating System</a> <a class="post-tag" href="/tags/dns/">DNS</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/">운영체제</a> <a class="post-tag" href="/tags/%ED%86%A0%EB%B9%84%EC%9D%98-%EC%8A%A4%ED%94%84%EB%A7%81/">토비의 스프링</a> <a class="post-tag" href="/tags/gof/">Gof</a> <a class="post-tag" href="/tags/os/">OS</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/network-study-01/"><div class="card-body"> <em class="small" data-ts="1649862000" data-df="ll" > Apr 14, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[네트워크 스터디] Chapter_01 웹 브라우저가 메세지를 만든다</h3><div class="text-muted small"><p> 📗 Chapter_01 웹 브라우저가 메세지를 만든다 1. HTTP 리퀘스트 메세지를 작성한다 1️⃣  URL ✔️ HTTP URL 의 구성 ex ) http://user:password@www.example.co.kr:80/dir/file1.html 프로토콜 → http 사용자명 (생략 가능) → user 패스워드 (생략 가능)...</p></div></div></a></div><div class="card"> <a href="/posts/dns/"><div class="card-body"> <em class="small" data-ts="1651330800" data-df="ll" > May 1, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>DNS 란?</h3><div class="text-muted small"><p> 브라우저에 “www.naver.com” 입력하면? DNS가 무엇인지 알아보기 전에 먼저 브라우저에 “www.naver.com” 을 입력했을 때 어떻게 해당 도메인의 IP를 조회하는지 알아보자 브라우저 애플리케이션이 “도메인명”을 조회하는 DNS 리졸버 호출 DNS 리졸버가 DNS 서버에 보내는 조회 메시지를 생성 프로토콜 스택이 DN...</p></div></div></a></div><div class="card"> <a href="/posts/network-study-04/"><div class="card-body"> <em class="small" data-ts="1654614000" data-df="ll" > Jun 8, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[네트워크 스터디] Chapter_04 엑세스 회선을 통해 인터넷의 내부로 !</h3><div class="text-muted small"><p> ADSL 기술을 이용한 엑세스 회선의 구조와 동작 ✔️  인터넷의 기본은 가정이나 회사의 LAN과 같다 인터넷은 거대하고 복잡한 시스템이지만 패킷을 중재하는 부분은 가정, 회사의 LAN과 동일하다. 라우터의 기본적인 구조나 동작도 전혀 다르지 않다 가정이나 회사의 네트워크 규모가 커진 것이 인터넷 ✔️ 가정, 회사의 네트워크와 인터...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/os-study-12/" class="btn btn-outline-primary" prompt="Older"><p>[운영체제 스터디] 파일 시스템</p></a> <a href="/posts/dns/" class="btn btn-outline-primary" prompt="Newer"><p>DNS 란?</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/gzgzg2">박우람</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%EB%B0%98%ED%9A%A8%EA%B2%BD/">반효경</a> <a class="post-tag" href="/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80-%EC%A0%95%EB%B3%B4%EA%B8%B0%EC%88%A0%EC%9D%98-%EC%9B%90%EB%A6%AC/">운영체제와 정보기술의 원리</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/operating-system/">Operating System</a> <a class="post-tag" href="/tags/dns/">DNS</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/">운영체제</a> <a class="post-tag" href="/tags/%ED%86%A0%EB%B9%84%EC%9D%98-%EC%8A%A4%ED%94%84%EB%A7%81/">토비의 스프링</a> <a class="post-tag" href="/tags/gof/">Gof</a> <a class="post-tag" href="/tags/os/">OS</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
