<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.1" /><meta property="og:title" content="[토비의 스프링] 토비의 스프링 3.1 2장 테스트" /><meta property="og:locale" content="en" /><meta name="description" content="게시글에는 책의 설명과 무관한 내용이 섞여있습니다. 테스트 계속 변화하는 애플리케이션에 대응하는 첫번째 전략이 확장과 변화를 고려한 객체지향 설계와 그것을 효과적으로 담아낼 수 있는 IoC/DI 같은 기술이라면 두번째 전략은 만들어진 코드를 확신할 수 있게 해주고 변화에 유연하게 대처할 수 있는 테스트 기술이다. 스프링으로 개발하면서 테스트를 만들지 않는다면 이는 스프링이 지는 가치의 절반을 포기하는 셈이다." /><meta property="og:description" content="게시글에는 책의 설명과 무관한 내용이 섞여있습니다. 테스트 계속 변화하는 애플리케이션에 대응하는 첫번째 전략이 확장과 변화를 고려한 객체지향 설계와 그것을 효과적으로 담아낼 수 있는 IoC/DI 같은 기술이라면 두번째 전략은 만들어진 코드를 확신할 수 있게 해주고 변화에 유연하게 대처할 수 있는 테스트 기술이다. 스프링으로 개발하면서 테스트를 만들지 않는다면 이는 스프링이 지는 가치의 절반을 포기하는 셈이다." /><link rel="canonical" href="https://gzgzg2.github.io//posts/toby-spring-chapter-2/" /><meta property="og:url" content="https://gzgzg2.github.io//posts/toby-spring-chapter-2/" /><meta property="og:site_name" content="일하는 냐옹이" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-10-05T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[토비의 스프링] 토비의 스프링 3.1 2장 테스트" /><meta name="twitter:site" content="@none" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-10-05T00:00:00+09:00","datePublished":"2022-10-05T00:00:00+09:00","description":"게시글에는 책의 설명과 무관한 내용이 섞여있습니다. 테스트 계속 변화하는 애플리케이션에 대응하는 첫번째 전략이 확장과 변화를 고려한 객체지향 설계와 그것을 효과적으로 담아낼 수 있는 IoC/DI 같은 기술이라면 두번째 전략은 만들어진 코드를 확신할 수 있게 해주고 변화에 유연하게 대처할 수 있는 테스트 기술이다. 스프링으로 개발하면서 테스트를 만들지 않는다면 이는 스프링이 지는 가치의 절반을 포기하는 셈이다.","headline":"[토비의 스프링] 토비의 스프링 3.1 2장 테스트","mainEntityOfPage":{"@type":"WebPage","@id":"https://gzgzg2.github.io//posts/toby-spring-chapter-2/"},"url":"https://gzgzg2.github.io//posts/toby-spring-chapter-2/"}</script><title>[토비의 스프링] 토비의 스프링 3.1 2장 테스트 | 일하는 냐옹이</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="일하는 냐옹이"><meta name="application-name" content="일하는 냐옹이"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/profile/navi_1.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">일하는 냐옹이</a></div><div class="site-subtitle font-italic">잠 자는게 좋아</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/gzgzg2" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/none" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['parkuram12','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[토비의 스프링] 토비의 스프링 3.1 2장 테스트</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>[토비의 스프링] 토비의 스프링 3.1 2장 테스트</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1664895600" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Oct 5, 2022 </em> </span> <span> Updated <em class="" data-ts="1664928000" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Oct 5, 2022 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://github.com/gzgzg2">박우람</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5376 words"> <em>29 min</em> read</span></div></div></div><div class="post-content"><blockquote><p>게시글에는 책의 설명과 무관한 내용이 섞여있습니다.</p><h1 id="테스트">테스트</h1><p>계속 변화하는 애플리케이션에 대응하는 첫번째 전략이 확장과 변화를 고려한 객체지향 설계와 그것을 효과적으로 담아낼 수 있는 IoC/DI 같은 기술이라면</p><p>두번째 전략은 만들어진 코드를 확신할 수 있게 해주고 변화에 유연하게 대처할 수 있는 테스트 기술이다. 스프링으로 개발하면서 테스트를 만들지 않는다면 이는 스프링이 지는 가치의 절반을 포기하는 셈이다.</p></blockquote><h3 id="userdaotest-다시보기"> <a href="#userdaotest-다시보기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> UserDaoTest 다시보기</h3><h3 id="테스트의-유용성"> <a href="#테스트의-유용성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 테스트의 유용성</h3><ul><li>처음과 동일한 기능을 수행함을 보장해줄 수 있는 방법은 바로 <code class="language-plaintext highlighter-rouge">테스트</code>이다.<li>테스트란 결국 <code class="language-plaintext highlighter-rouge">내가 예상하고 의도했던 대로 코드가 정확히 동작하는지 검증</code>하기 위한 작업<li>테스트가 정확히 동작하지 않는다는 것은 코드나 설계에 결함이 있음을 알 수 있음. 즉 개발자는 테스트를 통해 코드의 결함을 제거할 수 있음</ul><h3 id="웹을-통한-dao-테스트의-문제점"> <a href="#웹을-통한-dao-테스트의-문제점" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 웹을 통한 DAO 테스트의 문제점</h3><p>보통 웹 프로그램에서 DAO를 테스트하려면 웹 프로그램을 실행하기 위한 모든 계층의 코드를 전부 작성하고 이를 서버에 배치한뒤 실행시켜서 직접 사용자가 사용하는 방식처럼 테스트 해야한다.</p><p>이러한 테스트는 비효율적이다. 첫번째 문제점은 DAO를 테스트하기 위한 부가작업이 너무 많다는 점이고 두번째는 목적은 DAO 테스트지만 다른 계층에서 문제가 발생하면 그 문제를 찾아내야한다는 수고가 필요하다.</p><p>목적은 DAO 테스트 였는데 다른 계층의 코드와 컴포넌트, 그리고 서버 설정 상태까지 모두 테스트에 영향을 줄 수 있기 때문에 직접 웹 프로그램을 실행시켜서 테스트 하는 방법은 비효율적이다.</p><h3 id="작은-단위의-테스트"> <a href="#작은-단위의-테스트" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 작은 단위의 테스트</h3><ul><li>테스트하고자 하는 대상이 명확하다면 그 대상에만 집중해서 테스트하는 것이 바람직함<li>테스트는 가능하면 작은 단위로 쪼개서 집중해서 할 수 있어야 한다.<li>통제할 수 없는 외부의 리소스에 의존하는 테스트는 단위 테스트라고 보기 어려울 수 있음<li>외부 리소스에 의존하는 경우 통합 테스트나 인수 테스트를 이용하여 검증할 필요가 있음<li>많은 단위가 참여하는 테스트는 문제의 원인을 찾는게 어려울 수 있으니 단위 테스트로 먼저 검증을 하고 난 뒤에 단위를 묶어 테스트 하는 것이 바람직</ul><h3 id="지속적인-개선과-점직전인-개발을-위한-테스트"> <a href="#지속적인-개선과-점직전인-개발을-위한-테스트" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 지속적인 개선과 점직전인 개발을 위한 테스트</h3><ul><li>처음 만든 초난감 DAO 코드를 객체지향적 코드로 발전시키는 과정의 일등 공신은 테스트였음<li>테스트가 없었다면 다양한 방법을 동원해서 코드를 수정하고 설계를 개선해나가는 과정이 미덥지 않을 수 있고 마음이 불편해지면서 개선을 멈췄을 수도 있음<li>결론은 DAO 기능을 검증해주는 테스트가 있었기 때문에 점직적으로 코드를 개선할 수 있었던 것. 코드의 결함도 테스트를 통해 빠르게 알아낼 수 있었음<li>테스트를 이용하면 새로운 기능의 정상동작을 확인할 뿐만 아니라 기존에 만들어뒀던 코드가 새로운 기능을 위해 수정한 코드로 인해 영향을 받지 않는지 확인할 수 있음</ul><h3 id="main을-이용한-테스트의-문제점"> <a href="#main을-이용한-테스트의-문제점" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> main()을 이용한 테스트의 문제점</h3><p><strong>수동 확인 작업의 번거로움</strong></p><p>UserDaoTest는 수행하는 과정과 입력 데이터의 준비를 모두 자동으로 진행하지만 값이 올바른지는 출력된 데이터를 보고 개발자가 판단해야 한다. 즉 테스트 수행은 코드에 의해 자동적으로 진행되지만 결과를 확인하는 일은 사람의 책임이므로 완전히 자동으로 테스트되는 방법이라고 말할 수 없다. 이러한 방법은 검증할 단위가 적을때는 문제가 되지 않지만 테스트가 커질수록 불편하다. 또한 작은 차이는 발견하지 못하고 지나칠 수 있다.</p><p><strong>실행 작업의 번거로움</strong></p><p>간단히 실행 가능한 main() 메소드라고 해도 매번 실행하는 것은 번거로울 수 있다. 테스트할 클래스가 수백개가 되고 main() 메소드도 그만큼 만들어진다면 전체 기능을 테스트하기 위해 main() 메소드를 수백번 실행해야하는 수고가 필요하다. 그리고 결과를 확인하는 것도 사람의 몫이기 때문에 수백개의 실행결과를 보고 정상수행인지 직접 확인해야한다. 결론은 main() 메소드를 실행하는 방법보다 좀 더 편리하고 체계적으로 테스트를 실행하고 그 결과를 확인하는 방법이 필요하다.</p><h2 id="테스트의-효율적인-수행과-결과-관리"> <a href="#테스트의-효율적인-수행과-결과-관리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 테스트의 효율적인 수행과 결과 관리</h2><p>main 메소드로는 편리한 수행과 편리한 결과 확인이 어렵다. 때문에 일정한 패턴을 가진 테스트를 만들 수 있고, 많은 테스트를 간단하게 실행시키고, 테스트 결과를 간단하게 확인하고 실패한 곳을 빠르게 찾아갈 수 있는 기능을 갖춘 테스트 지원 도구와 그에 맞는 테스트 작성 방법이 필요하다.</p><h3 id="junit-테스트로-전환"> <a href="#junit-테스트로-전환" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> Junit 테스트로 전환</h3><p>Junit은 프레임워크이다. 프레임워크의 기본 동작원리는 제어의 역전이다. 프레임워크는 개발자가 만든 클래스의 제어 권한을 넘겨받아서 주도적으로 애플리케이션 흐름을 제어한다. Junit도 개발자가 만든 클래스의 오브젝트를 생성하고 실행하는 일을 대신한다. 따라서 프레임워크에서 동작하는 코드는 main() 메소드도 필요없고 오브젝트를 만들어서 실행시키는 코드를 만들 필요도 없다.</p><h3 id="테스트-메소드-전환"> <a href="#테스트-메소드-전환" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 테스트 메소드 전환</h3><p>새로 만들 테스트 메소드는 Junit 프레임워크가 요구하는 두가지 조건을 따라야한다.</p><ol><li>메소드가 public으로 선언되어야 한다.<li>테스트 메소드의 리턴값은 void여야 한다.<li>메소드에 @Test라는 애노테이션을 붙여줘야 한다.</ol><h3 id="빌드-툴"> <a href="#빌드-툴" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 빌드 툴</h3><p>개발자 개인별로 IDE에서 Junit 도구를 사용해 테스트를 실행하는 것이 가장 편리하지만 여러 개발자가 만든 테스트 코드를 통합해서 테스트를 수행해야 할 때는 서버에서 모든 코드를 가져와 통합하고 빌드한 뒤애 테스트를 수행하는 것이 좋다. 이떄는 빌드 스크립트를 이용해 Junit 테스트를 실행하고 결과를 메일로 통보받는 방법을 사용하면 된다.</p><p><strong>(개인적인 생각)</strong> 위와같은 상황 뿐만 아니라 테스트가 너무 많아 실행시간이 오래 소요되는 경우도 빌드 스크립트를 이용하면 좋은 해결 방법이 될 수 있을 것 같다.</p><h3 id="테스트-결과의-일관성"> <a href="#테스트-결과의-일관성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 테스트 결과의 일관성</h3><ul><li>테스트의 결과가 외부 상태에 따라 성공하기도 실패하기도 한다는 것은 큰 문제이다. 테스트는 코드가 변경되지 않으면 항상 동일한 결과를 내야한다.<li>기존 UserDaoTest의 문제는 이전 테스트 때문에 DB에 등록된 중복 데이터가 있을 수 있다는 점이다.<li>가장 좋은 해결책은 addAndGet() 테스트를 마치고 나면 테스트를 위해 등록된 데이터를 삭제해서 테스트를 수행하기 이전 상태로 만들어주는 것이다.<li>이러한 방식을 사용하면 테스트를 여러번 반복해서 실행하더라도 항상 동일한 결과를 얻을 수 있다.</ul><h3 id="포괄적인-테스트"> <a href="#포괄적인-테스트" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 포괄적인 테스트</h3><ul><li>테스트를 만들지 않는 것도 위험한 일이지만 성의없이 테스트를 만드는 바람에 문제가 있는 코드인데도 테스트가 성공하게 만드는 것은 더 위험하다.<li>특히 한 가지 결과만 검증하고 마는 것은 상당히 위험하다. 이런 테스트는 마치 하루에 두 번은 정확히 맞는다는 시계와 같을 수 있다.<li>모든 코드의 수정 후에는 그 수정에 영향을 받을만한 테스트를 실행하는 것을 잊지 말아야한다. (사이드 이펙트 체크)<li>모든 테스트는 실행 순서에 상관없이 독립적으로 항상 동일한 결과를 낼 수 있도록 해야한다.<li>성공하는 테스트 뿐만 아니라 실패하는 경우의 테스트도 작성해야 한다. 실패하는 테스트를 작성하면 예외적인 상황을 빠뜨리지 않는 꼼꼼한 개발이 가능하다.</ul><h3 id="테스트-주도-개발tdd"> <a href="#테스트-주도-개발tdd" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 테스트 주도 개발(TDD)</h3><blockquote><p>테스트 코드를 먼저 작성하고 이후 <code class="language-plaintext highlighter-rouge">테스트 코드에서 정의된 기능</code>을 프로덕션 코드로 작성하여 테스트를 성공하게 하는 방식의 개발 방법을 <code class="language-plaintext highlighter-rouge">테스트 주도 개발(TDD)</code> 이라고 한다.</p><p>테스트에 만들고 싶은 기능의 대한 조건과 행위 결과에 대한 내용이 잘 표현되어있으면 테스트 코드가 기능 정의서의 역할을 대신할 수 있다.</p></blockquote><ul><li>TDD는 테스트를 만들고 그 테스트가 성공하도록 하는 코드만 만드는 식으로 진행하기 때문에 테스트를 빼먹지 않고 꼼꼼하게 만들어낼 수 있다.<li>또한 테스트를 작성하는 시간과 애플리케이션 코드를 작성하는 시간의 간격이 짧아진다.<li>테스트를 작성하고 이를 성공시키는 코드를 만드는 작업의 주기는 짧게 가져가는 것이 좋다.<li>사실 개발자는 TDD를 몰라도 이미 테스트가 개발을 이끄는 방식으로 개발을 하고 있다고 생각한다. 머릿속으로 기능 정의서를 그려놓고 정의서에 맞춰서 개발하기 때문이다.<ul><li>문제는 이렇게 머릿속으로 진행하는 테스트는 제약이 심하고, 오류가 많고, 다시 반복하기 힘들다는 점이다.<li>차라리 머릿속으로 복잡하게 진행하던 테스트를 실제 코드로 끄집어 내놓으면 이게 바로 TDD가 된다.</ul></ul><p><strong>(개인적인 생각)</strong> 간단하게 성공시키는 코드를 작성하고 테스트를 수행하면서 개선하는 방법이 이미 완성된 프로덕션 코드를 작성하는 것보다 효율적이고 문제점을 빠르게 찾을 수 있다고 생각한다.</p><h3 id="junit의-테스트-독립성-보장"> <a href="#junit의-테스트-독립성-보장" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> Junit의 테스트 독립성 보장</h3><blockquote><p>junit은 각 테스트 메소드를 실행할 때마다 테스트 클래스의 인스턴스를 새로 생성한다. 한번 만들어진 테스트 클래스의 오브젝트는 하나의 테스트 메소드를 사용하고나면 버려진다. 테스트 클래스가 @Test 테스트 메소드를 2개 가지고 있다면 테스트 클래스의 인스턴스는 두 번 생성된다. 이러한 방법을 사용하는 이유는 각 테스트의 독립성을 보장하기 위해서이다.</p><p>그러나 ApplicationContext 처럼 생성에 많은 시간과 자원이 소모되는 경우에는 테스트 전체가 공유하는 오브젝트를 만들기도 한다. 이때도 테스트는 일관성있는 실행 결과를 보장해야하고, 테스트의 실행 순서과 결과에 영향을 미치지 않아야 한다.</p></blockquote><h3 id="픽스처"> <a href="#픽스처" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 픽스처?</h3><p>테스트를 수행하는 데 필요한 정보나 오브젝트를 픽스처(fixture)라고 한다. 일반적으로 픽스처는 여러 테스트에서 반복적으로 사용되기 때문에 @Before 메소드를 이용해서 생성해두면 편리하다.</p><h3 id="di와-테스트"> <a href="#di와-테스트" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> DI와 테스트</h3><p>구현체가 절대 변하지 않는다고 해도 DI를 사용해야 하는 세가지 이유가 있다.</p><p><strong>첫째,</strong> 소프트웨어 개발에서 절대 바뀌지 않는 것은 없다. 클래스 대신 인터페이스를 사용하고 new를 이용해 생성하게 하는 대신 DI를 통해 주입받게 하는 것은 아주 단순하고 쉬운 작업이다.</p><p><strong>둘째,</strong> 구현체가 변경되지 않는다고 해도 인터페이스를 두고 DI를 적용하게 해두면 기존의 서비스 기능 자체를 확장할 수 있기 때문이다.</p><p><strong>셋째,</strong> 세번째 이유는 테스트 때문이다. 단지 효율적인 테스트를 손쉽개 만들기 위해서라도 DI를 적용해야 한다. 테스트를 잘 활용하려면 자동으로 실행 가능하며 빠르게 동작하도록 테스트 고드를 만들어야 한다. DI는 테스트가 작은 단위의 대상에 대해 독립적으로 만들어지고 실행되게 하는데 중요한 역할을 한다.</p><h3 id="dirtiescontext"> <a href="#dirtiescontext" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> DirtiesContext</h3><p>스프링 테스트 컨텍스트 프레임워크를 적용하면 애플리케이션 컨텍스트는 테스트 중에 딱 하나만 만들어지고 모든 테스트에서 공유한다. 이러한 상황에서 애플리케이션 컨텍스트의 구성이나 상태를 하나의 테스트를 위해 변경하면 나머지 모든 테스트에도 영향을 끼칠 수 있어 위험하다.</p><p>이러한 문제는 <code class="language-plaintext highlighter-rouge">@DirtiesContext</code>를 사용하면 어느정도 해결될 수 있다. 이 어노테이션이 붙은 테스트 클래스에는 애플리케이션 컨텍스트 공유를 허용하지 않는다. 하지만 클래스 위에 <code class="language-plaintext highlighter-rouge">@DirtiesContext</code>를 선언할 경우 해당 클래스의 테스트를 실행할 때마다 애플리케이션 컨텍스트를 새로 만들기 때문에 완벽한 해결 방법이라고 보기엔 어렵다.</p><div class="language-text highlighter-rouge"><div class="code-header"> <span data-label-text="Text"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>하나의 메소드에서만 컨텍스트 상태를 변경한다면 메소드 레벨에 @DirtiesContext 를 붙여주는 것이 더 낫다. 
해당 메소드의 실행이 끝나고 나면 이후에 진행되는 테스트를 위해 변경된 애플리케이션 컨텍스트는 폐기되고 새로운 애플리케이션 컨텍스트가 만들어진다.
</pre></table></code></div></div><h3 id="테스트를-위한-별도의-di-설정"> <a href="#테스트를-위한-별도의-di-설정" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 테스트를 위한 별도의 DI 설정</h3><ul><li>테스트에서 사용될 applicationContext를 따로 정의해두면 테스트에 필요한 설정 정보만 사용할 수 있으므로 효율적으로 테스트 할 수 있다.<li>테스트하기 불편하게 설계된 코드가 좋은 코드일 확률은 매우 낮다.</ul><h3 id="di를-이용한-테스트-방법-선택"> <a href="#di를-이용한-테스트-방법-선택" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> DI를 이용한 테스트 방법 선택</h3><ul><li>스프링 컨테이너 없이 테스트할 수 있는 방법을 가장 우선적으로 고려<ul><li>이 방법이 테스트 수행속도가 가장 빠르다</ul><li>여러 오브젝트와 복잡한 의존관계를 맺을 경우 스프링의 설정을 이용한 DI 방식의 테스트를 이용하면 편리함<li>예외적인 의존관계를 강제로 구성해야할 경우 수동 DI 해서 테스트하는 방법을 고려할 수 있음.</ul><h3 id="학습-테스트로-배우는-스프링"> <a href="#학습-테스트로-배우는-스프링" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 학습 테스트로 배우는 스프링</h3><ul><li>보통 개발자는 자신이 작성한 기능에 대해서만 테스트를 작성하면 됨<li>그러나 때로는 자신이 만들지않은 프레임워크나 다른 개발팀에서 만들어서 제공한 라이브러리 등에서도 테스트를 작성할 수도 있음<ul><li>이러한 테스트를 <code class="language-plaintext highlighter-rouge">학습 테스트</code> 라고 함</ul><li>학습 테스트의 목적은 자신이 사용할 API나 프레임워크의 기능을 테스트로 보면서 사용 방법을 익히려는 것<ul><li>프레임워크나 라이브러리에 대한 검증이 아닌 자신이 얼마나 해당 기술이나 기능을 제대로 이해하고 있는지 확인하는 목적</ul></ul><h3 id="학습-테스트의-장점"> <a href="#학습-테스트의-장점" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 학습 테스트의 장점</h3><ul><li>다양한 조건에 따른 기능을 손쉽게 확인해볼 수 있음<li>학습 테스트 코드를 개발 중에 참고할 수 있음<li>프레임워크나 제품을 업그레이드할 떄 호환성 검증을 도와줌<li>테스트 작성에 대한 좋은 훈련이 됨<li>새로운 기술을 공부하는 과정이 즐거워짐</ul><h3 id="버그테스트"> <a href="#버그테스트" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 버그테스트</h3><ul><li>QA팀의 테스트 중 기능에서 오류를 발견했다고 가정했을 때 무턱대고 코드를 수정하는 것보다 버그 테스트를 만들어보는 편이 유용하다.<li>버그 테스트는 처음에 버그가 원인이되어 실패하게 만들고 이후에 버그 테스트가 성공할 수 있도록 애플리케이션 코드를 수정한다.<ul><li>이떄 테스트가 성공하면 버그는 수정된 것</ul></ul><p><strong>장점</strong></p><ol><li>테스트의 완성도를 높여준다.<ul><li>기존 테스트에서 발견하지 못한 이슈를 버그 테스트를 통해 완성도 향상</ul><li>버그의 내용을 명확하게 분석하게 해준다<ul><li>버그를 테스트로 만들어서 실패하게 하려면 버그의 원인을 명확히 알아야한다.<li>때문에 버그를 효과적으로 분석 가능</ul><li>기술적인 문제를 해결하는 데 도움이 된다.<ul><li>버그가 있는 것은 알지만 원인을 파악하기 힘들 때 도움이 됨<li>코드 분석으로 파악하기 힘들경우 동일한 문제가 발생하는 가장 단순한 코드와 그에 대한 버그 테스트를 만들어보면 도움이 됨</ul></ol><div class="language-text highlighter-rouge"><div class="code-header"> <span data-label-text="Text"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>
- 동등분할
같은 결과를 내는 값의 범위를 구분해서 각 대표 값으로 테스트하는 방법
어떤 작업의 결과 종류가 true, false, 또는 예외발생 세 가지라면 각 결과를 내는 입력 값이나 상황의 조합을 
만들어서 모든 경우에 대한 테스트를 해보는 것이 좋음

- 경계값 분석
에러는 동등분할 범위의 경계에서 주로 발생한다는 특징을 이용해서 경계의 근처에 있는 값을 이용해 테스트하는 방법
보통 숫자의 입력 값인 경우 0이나 그 주변 값 또는 정수의 최대값, 최소값 등으로 테스트 해보면 도움이 될 때가 많음
</pre></table></code></div></div><h2 id="정리"> <a href="#정리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a> 정리</h2><ul><li>테스트는 자동화 되어야 하고 빠르게 실행되어야 함<li>main() 테스트보다 junit 프레임워크를 이용한 테스트가 생산적임<li>테스트를 작성할 때 스프링에 의존하지 않는 테스트 작성 방법을 첫번째로 고려해보기<li>테스트 작성이 힘든 코드는 잘 설계된 코드라고 할 수 없음<li>테스트코드 작성 주기와 실제 기능 구현 주기는 짧게 가져가야 함<li>성의없이 테스트를 작성하지 말 것 (문제가 있는 코드인데 테스트를 통과하게 되면 곤란)<li>오류가 발견될 경우 그에 대한 버그 테스트를 만들어두면 유용<li>학습 테스트를 통해 프레임워크나 라이브러리에 대한 이해도를 검증할 수 있음<li>스프링을 사용하지 않더라도 DI는 유연한 테스트를 가능하게 해줌<li>기능을 먼저 구현하고 테스트를 작성하는 것이 아닌, 테스트를 먼저 작성하고 기능을 구현하는 TDD 방식을 고려해볼 수도 있음.</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/toby/'>Toby</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/spring/" class="post-tag no-text-decoration" >Spring</a> <a href="/tags/%ED%86%A0%EB%B9%84%EC%9D%98-%EC%8A%A4%ED%94%84%EB%A7%81/" class="post-tag no-text-decoration" >토비의 스프링</a> <a href="/tags/%ED%86%A0%EB%B9%84%EC%9D%98-%EC%8A%A4%ED%94%84%EB%A7%81-2%EC%9E%A5/" class="post-tag no-text-decoration" >토비의 스프링 2장</a> <a href="/tags/%ED%85%8C%EC%8A%A4%ED%8A%B8/" class="post-tag no-text-decoration" >테스트</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%5B%ED%86%A0%EB%B9%84%EC%9D%98+%EC%8A%A4%ED%94%84%EB%A7%81%5D+%ED%86%A0%EB%B9%84%EC%9D%98+%EC%8A%A4%ED%94%84%EB%A7%81+3.1+2%EC%9E%A5+%ED%85%8C%EC%8A%A4%ED%8A%B8+-+%EC%9D%BC%ED%95%98%EB%8A%94+%EB%83%90%EC%98%B9%EC%9D%B4&url=https%3A%2F%2Fgzgzg2.github.io%2F%2Fposts%2Ftoby-spring-chapter-2%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%5B%ED%86%A0%EB%B9%84%EC%9D%98+%EC%8A%A4%ED%94%84%EB%A7%81%5D+%ED%86%A0%EB%B9%84%EC%9D%98+%EC%8A%A4%ED%94%84%EB%A7%81+3.1+2%EC%9E%A5+%ED%85%8C%EC%8A%A4%ED%8A%B8+-+%EC%9D%BC%ED%95%98%EB%8A%94+%EB%83%90%EC%98%B9%EC%9D%B4&u=https%3A%2F%2Fgzgzg2.github.io%2F%2Fposts%2Ftoby-spring-chapter-2%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fgzgzg2.github.io%2F%2Fposts%2Ftoby-spring-chapter-2%2F&text=%5B%ED%86%A0%EB%B9%84%EC%9D%98+%EC%8A%A4%ED%94%84%EB%A7%81%5D+%ED%86%A0%EB%B9%84%EC%9D%98+%EC%8A%A4%ED%94%84%EB%A7%81+3.1+2%EC%9E%A5+%ED%85%8C%EC%8A%A4%ED%8A%B8+-+%EC%9D%BC%ED%95%98%EB%8A%94+%EB%83%90%EC%98%B9%EC%9D%B4" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div><script src="https://utteranc.es/client.js" repo="gzgzg2/blog-comments" issue-term="pathname" label="Comment🐱" theme="github-light" crossorigin="anonymous" async> </script></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/strategy-pattern/">[Java Design Pattern] Strategy Pattern</a><li><a href="/posts/http2/">HTTP/2</a><li><a href="/posts/toby-spring-chapter-2/">[토비의 스프링] 토비의 스프링 3.1 2장 테스트</a><li><a href="/posts/toby-spring-chapter-1/">[토비의 스프링] 토비의 스프링 3.1 1장 오브젝트와 의존관계</a><li><a href="/posts/spring-applicationcontext/">SpringFramework - Web ApplicationContext</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%EB%B0%98%ED%9A%A8%EA%B2%BD/">반효경</a> <a class="post-tag" href="/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80-%EC%A0%95%EB%B3%B4%EA%B8%B0%EC%88%A0%EC%9D%98-%EC%9B%90%EB%A6%AC/">운영체제와 정보기술의 원리</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/operating-system/">Operating System</a> <a class="post-tag" href="/tags/dns/">DNS</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/">운영체제</a> <a class="post-tag" href="/tags/%ED%86%A0%EB%B9%84%EC%9D%98-%EC%8A%A4%ED%94%84%EB%A7%81/">토비의 스프링</a> <a class="post-tag" href="/tags/gof/">Gof</a> <a class="post-tag" href="/tags/os/">OS</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/toby-spring-start/"><div class="card-body"> <em class="small" data-ts="1661698800" data-df="ll" > Aug 29, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[토비의 스프링] 토비의 스프링 3.1 시작하기</h3><div class="text-muted small"><p> 게시글에는 책의 설명과 무관한 내용이 섞여있습니다. 토비의 스프링 3.1 정독 시작하기 토비의 스프링 책을 구매한지 벌써 1년이 지났는데 현재까지 책을 다 읽지 못하고 있었다. 올해가 가기전에 정독을 하기 위해서 11월쯤 토비의 스프링 책 스터디를 진행하려던 찰나 아주 좋은 기회가 생겼다 😆 바로 책의 저자분이 직접 운영하시는 읽기모임에 참...</p></div></div></a></div><div class="card"> <a href="/posts/toby-spring-chapter-1/"><div class="card-body"> <em class="small" data-ts="1663426800" data-df="ll" > Sep 18, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[토비의 스프링] 토비의 스프링 3.1 1장 오브젝트와 의존관계</h3><div class="text-muted small"><p> 게시글에는 책의 설명과 무관한 내용이 섞여있습니다. 오브젝트와 의존관계 DAO(Data Access Object)는 DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트를 말한다. 초난감 DAO 현재 초난감 UserDao의 코드는 객체지향적이지 않음. 예제 그대로일 경우 exception이 발생하면 리소스 해제가...</p></div></div></a></div><div class="card"> <a href="/posts/spring-applicationcontext/"><div class="card-body"> <em class="small" data-ts="1645439489" data-df="ll" > Feb 21, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>SpringFramework - Web ApplicationContext</h3><div class="text-muted small"><p> 1. IoC 컨테이너 : 빈 팩토리와 애플리케이션 컨텍스트 스프링 애플리케이션에서는 오브젝트의 생성과 관계설정, 사용, 제거 등의 작업을 애플리케이션 코드 대신 독립적인 컨테이너가 담당한다. 이를 컨테이너가 코드 대신 오브젝트 제어권을 갖고있다고 해서 IoC 라고 부른다. 그래서 스프링 컨테이너를 IoC 컨테이너 라고도 한다. 스프링에...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/toby-spring-chapter-1/" class="btn btn-outline-primary" prompt="Older"><p>[토비의 스프링] 토비의 스프링 3.1 1장 오브젝트와 의존관계</p></a> <a href="/posts/http2/" class="btn btn-outline-primary" prompt="Newer"><p>HTTP/2</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/gzgzg2">박우람</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%EB%B0%98%ED%9A%A8%EA%B2%BD/">반효경</a> <a class="post-tag" href="/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80-%EC%A0%95%EB%B3%B4%EA%B8%B0%EC%88%A0%EC%9D%98-%EC%9B%90%EB%A6%AC/">운영체제와 정보기술의 원리</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/operating-system/">Operating System</a> <a class="post-tag" href="/tags/dns/">DNS</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/">운영체제</a> <a class="post-tag" href="/tags/%ED%86%A0%EB%B9%84%EC%9D%98-%EC%8A%A4%ED%94%84%EB%A7%81/">토비의 스프링</a> <a class="post-tag" href="/tags/gof/">Gof</a> <a class="post-tag" href="/tags/os/">OS</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
